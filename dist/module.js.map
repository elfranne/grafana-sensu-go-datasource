{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///external \"moment\"","webpack:///external \"app/core/app_events\"","webpack:///external \"app/plugins/sdk\"","webpack:///./types.ts","webpack:///./sensu/sensu.ts","webpack:///./constants.ts","webpack:///./utils/datasource_filter_util.ts","webpack:///./utils/query_util.ts","webpack:///./transformer/table_transformer.ts","webpack:///./transformer/index.ts","webpack:///./transformer/timeseries_transformer.ts","webpack:///./utils/config_migration_util.ts","webpack:///./utils/data_aggregation_util.ts","webpack:///./datasource.ts","webpack:///./FieldSelector.ts","webpack:///./query_ctrl.ts","webpack:///./config_ctrl.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__3__","ServerSideFilterType","FIELD","LABEL","sensu","Sensu","query","datasource","options","_this","this","namespaces","external_lodash_default","a","isEmpty","url","push","queries","map","namespace","_doQuery","Promise","all","then","data","flatten","retryCount","fullUrl","method","apiBaseUrl","requestParameters","_getParameters","_authenticate","_request","result","catch","error","instanceSettings","tokens","delay","Math","floor","random","resolve","setTimeout","_isTokenExpired","_acquireAccessToken","token","timestampNow","Date","now","expiresAt","expires_at","expires_offset","tokenExpireOffset_s","expiresOffset","tokenTimeout_s","req","headers","Content-Type","apiKeyUrlPrefix","has","Authorization","access_token","params","backendSrv","datasourceRequest","_handleRequestResult","_handleRequestError","message","err","status","config","statusText","limit","responseFilters","fieldSelector","_buildFilterParameter","filter","type","labelSelector","filters","matcher","_parseGrafanaMultiValue","join","filterValue","grafanaMultiValueRegex","test","replace","RegExp","AGGREGATION_TYPES","text","requiresTarget","API_ENDPOINTS","fieldSelectors","QUERY_TYPES","FORMATS","TIME_PROPERTIES","_stringToRegex","regex","match","datasource_filter_util","operator","dataValue","_matchRegExp","filterNumber","Number","isFinite","console","warn","_matchNumber","components","_convertTimestamps","rows","each","row","attribute","index","length","time","defaultTo","external_moment_default","format","table_transformer","dataMatrix","vertical","columns","isArrayMarker","_a","isArray","times","isNil","uniq","_extractColumns","columnIndexMap","column","dataRow","constant","element","isPlainObject","JSON","stringify","columnName","dataColumns","dataRows","idx","_asVerticalTable","transformer","target","datapoints","timeseries_transformer","config_migration_util","version","clientSideFilters","serverSideFilters","init","log","filterSegments","segments","toVersion2","sum","SensuDatasource","templateSrv","prepareQuery","queryOptions","preparedTarget","apiUrl","_getApiUrl","clientFilters","cloneDeep","serverFilters","_resolveTemplateVariables","scopedVars","split","forEach","apiEndpoint","find","apiEndpoints","_timeCorrection","dataElement","set","unset","_queryGroupAndAggregate","prepTarget","alias","aggregationAlias","aggregationType","groupAttribute","groupBy","groups","dataGroup","groupKey","_queryAggregation","groupResult","groupAlias","_mergeTableAggregation","groupData","groupByAttribute","group","point","data_aggregation_util","Error","targetField","sumBy","aggregationField","_queryFieldSelection","columnMappings","_extractColumnMappings","mapping","path","flatMap","selector","resolvePaths","paths","_filterData","every","_matches","filterKey","elementValue","selection","lastSelector","basePath","fieldSegments","_deepResolve","keys","nestedKeys","_query","queryComponents","queryRegExp","matchResult","apiKey","selectedField","parseInt","filterRegExp","SERVER_FILTER_REG_EXP","whereClause","exec","query_util","_transformQueryComponentsToQueryOptions","resultAsPlainArray","queryType","isNaN","String","trim","$inject","targets","hide","queryTargets","parsedLimit","queryResults","queryResult","metricFindQuery","testDatasource","useApiKey","testUrl","FieldSelector","ctrl","initPath","refresh","dataPreview","slice","fieldType","uiSegmentSrv","newKey","attributePath","getPath","segment","restore","query_ctrl_SensuQueryCtrl","_super","SensuQueryCtrl","$scope","$injector","$q","aggregationTypes","queryTypes","formats","dataPreviewBuffer","clientFilterSegments","newOperator","newKeyValue","_createServerFilterSegments","newCondition","onAggregationFieldChange","segmentAggregationTarget","panelCtrl","onAggregationTypeChange","aggregationRequiresTarget","getCurrentAggregationType","_resetAggregation","removeGroupBy","newFake","getTargetOptions","getAllDeepKeys","option","newSegment","when","getGroupByOptions","onGroupByChange","groupBySegment","newPlusButton","unshift","variables","variable","onNamespaceChange","namespaceSegment","_reset","FieldSelector_0","serverFilterSegments","_updateFilterTarget","onApiChange","onQueryTypeChange","isServerFilter","splice","parentIndex","segmentValue","_addClientFilterSegment","sourceSegment","segmentArray","pop","_addServerFilterSegment","getFilterSegmentOptions","newOperators","options_1","filterKey_1","fake","combineKeys","e","getFieldSelectorOptions","currentSelection","fieldSegment","concat","sort","addFieldSegment","removeField","onAliasChange","_getCurrentApi","currentApi","field","response","endsWith","onRefresh","_createClientFilterSegments","aggregation","app_events_default","on","onResponseReceived","events","__extends","getCollapsedText","toUpperCase","queryLimit","targetToQueryString","templateUrl","SensuConfigCtrl","current","jsonData","basicAuth","resetApiKey","secureJsonFields","secureJsonData","currentUrl","$watch"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","import FieldSelector from './FieldSelector';\r\n\r\nexport interface AggregationType {\r\n  readonly value: string;\r\n  readonly text: string;\r\n  readonly requiresTarget: boolean;\r\n}\r\n\r\nexport interface ApiEndpoint {\r\n  readonly text: string;\r\n  readonly value: string;\r\n  readonly url: string;\r\n  readonly fieldSelectors: string[];\r\n}\r\n\r\nexport interface ColumnMapping {\r\n  path: string;\r\n  alias: string;\r\n}\r\n\r\nexport interface DataPoint {\r\n  readonly value: any;\r\n  readonly name: string;\r\n}\r\n\r\nexport interface BaseFilter {\r\n  key: string;\r\n  value: string;\r\n  matcher: string;\r\n}\r\n\r\nexport type ClientSideFilter = BaseFilter;\r\n\r\nexport interface ServerSideFilter extends BaseFilter {\r\n  type: ServerSideFilterType;\r\n}\r\n\r\nexport enum ServerSideFilterType {\r\n  FIELD = 0,\r\n  LABEL = 1,\r\n}\r\n\r\nexport interface InstanceSettings {\r\n  // the datasource url\r\n  url: string;\r\n\r\n  // whether basic auth is used\r\n  basicAuth: boolean;\r\n\r\n  // additional data\r\n  jsonData: JsonData;\r\n\r\n  // additional secured data\r\n  secureJsonData: SecureJsonData;\r\n\r\n  // map defining which secured data element is set\r\n  secureJsonFields: SecureJsonFields;\r\n}\r\n\r\nexport interface JsonData {\r\n  // copy of the current datasource url - used for dynamic routing\r\n  currentUrl: string;\r\n\r\n  // whether an API key should be used\r\n  useApiKey: boolean;\r\n}\r\n\r\nexport interface SecureJsonData {\r\n  // the specified API key\r\n  apiKey?: string;\r\n}\r\n\r\nexport interface SecureJsonFields {\r\n  // whether an API key has been stored by Grafana\r\n  apiKey?: boolean;\r\n}\r\n\r\nexport interface PreparedTarget {\r\n  readonly apiUrl: string;\r\n  readonly clientFilters: ClientSideFilter[];\r\n  readonly serverFilters: ServerSideFilter[];\r\n  readonly target: GrafanaTarget;\r\n}\r\n\r\nexport interface QueryComponents {\r\n  readonly apiKey: string;\r\n  readonly namespace: string;\r\n  readonly selectedField: string;\r\n  readonly clientFilters: ClientSideFilter[];\r\n  readonly serverFilters: ServerSideFilter[];\r\n  readonly limit: number;\r\n}\r\n\r\nexport interface TextValue {\r\n  readonly text: string;\r\n  readonly value: string;\r\n}\r\n\r\nexport interface QueryOptions {\r\n  method: string;\r\n  url: string;\r\n  namespaces: string[];\r\n  limit: number;\r\n  forceAccessTokenRefresh?: boolean;\r\n  responseFilters: ServerSideFilter[];\r\n}\r\n\r\nexport interface AccessToken {\r\n  readonly access_token: string;\r\n  readonly expires_at: number;\r\n  readonly refresh_token: string;\r\n  expires_offset?: number;\r\n}\r\n\r\nexport interface GrafanaTarget {\r\n  /** @deprecated */\r\n  filterSegments?: any[];\r\n  /** @deprecated */\r\n  aggregation?: string;\r\n\r\n  aggregationAlias?: string;\r\n  aggregationField?: string;\r\n  aggregationRequiresTarget?: boolean;\r\n  aggregationType?: string;\r\n  apiEndpoints: string;\r\n  fieldSelectors: FieldSelector[];\r\n  format: string;\r\n  groupAlias?: string;\r\n  groupBy?: string;\r\n  limit?: string;\r\n  namespace: string;\r\n  namespaces: string[]; // splitted and resolved namespace attribute\r\n  queryType: string;\r\n  refId: string;\r\n\r\n  version: number;\r\n  clientSideFilters: ClientSideFilter[];\r\n  serverSideFilters: ServerSideFilter[];\r\n}\r\n\r\nexport interface GrafanaUiSegment {\r\n  value: string;\r\n}\r\n\r\nexport interface GrafanaTimeSeries {\r\n  target: string; // time series name\r\n  datapoints: unknown[];\r\n}\r\n\r\nexport interface GrafanaTable {\r\n  columns: unknown[];\r\n  rows: unknown[][];\r\n  type: string;\r\n}\r\n","import _ from 'lodash';\r\nimport {\r\n  AccessToken,\r\n  QueryOptions,\r\n  ServerSideFilter,\r\n  ServerSideFilterType,\r\n} from '../types';\r\n\r\n/**\r\n * Class which encapsulates the query mechanism against the Sensu Go API.\r\n */\r\nexport default class Sensu {\r\n  /**\r\n   * The max duration a token is valid in seconds.\r\n   */\r\n  static readonly tokenTimeout_s = 600;\r\n  /**\r\n   * This duration will be susbtracted of the `tokenTimeout_s` duration.\r\n   */\r\n  static readonly tokenExpireOffset_s = 60;\r\n  /**\r\n   * The API's base url.\r\n   */\r\n  static readonly apiBaseUrl = '/api/core/v2';\r\n\r\n  /**\r\n   * The data source route used for API key authentication. See also the plugin.json file.\r\n   */\r\n  static readonly apiKeyUrlPrefix = '/api_key_auth';\r\n\r\n  /**\r\n   * Regex pattern for recognizing multi-values from Grafana template variables such as (ABC|DEF|GHI).\r\n   */\r\n  static readonly grafanaMultiValueRegex = new RegExp(/^\\s*[(].*[|].*[)]\\s*$/g);\r\n\r\n  /**\r\n   * Executes a query against the given datasource. An access token will be gathered if needed.\r\n   * For each namespace specified in the passed options, a separate query will be executed.\r\n   *\r\n   * @param datasource the datasource to use\r\n   * @param options the options specifying the query's request\r\n   */\r\n  static query(datasource: any, options: QueryOptions) {\r\n    const {namespaces} = options;\r\n\r\n    if (_.isEmpty(namespaces) && options.url === '/namespaces') {\r\n      namespaces.push(''); // dummy element to execute a query\r\n    }\r\n\r\n    const queries = _.map(namespaces, namespace =>\r\n      this._doQuery(datasource, options, namespace)\r\n    );\r\n\r\n    return Promise.all(queries).then(data => {\r\n      return _.flatten(data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes a query against the given datasource. An access token will be gathered if needed.\r\n   *\r\n   * @param datasource the datasource to use\r\n   * @param options the options specifying the query's request\r\n   * @param namespace the namespace used by this query\r\n   */\r\n  static _doQuery(\r\n    datasource: any,\r\n    options: QueryOptions,\r\n    namespace: string,\r\n    retryCount = 0\r\n  ) {\r\n    const {method, url} = options;\r\n\r\n    let fullUrl: string;\r\n    if (url === '/namespaces') {\r\n      fullUrl = Sensu.apiBaseUrl + '/namespaces';\r\n    } else {\r\n      const namespacePath = namespace === '*' ? '' : '/namespaces/' + namespace;\r\n      fullUrl = Sensu.apiBaseUrl + namespacePath + url;\r\n    }\r\n\r\n    const requestParameters = this._getParameters(options);\r\n\r\n    return Sensu._authenticate(datasource)\r\n      .then(() => Sensu._request(datasource, method, fullUrl, requestParameters))\r\n      .then(result => result.data)\r\n      .catch(error => {\r\n        // we'll retry once\r\n        if (retryCount >= 1) {\r\n          throw error;\r\n        }\r\n\r\n        // delete token details in order to refresh the token in case of basic auth\r\n        delete datasource.instanceSettings.tokens;\r\n\r\n        // the retry is not immediatly done in order to prevent some race conditions\r\n        const delay = Math.floor(1000 + Math.random() * 1000);\r\n\r\n        return new Promise(resolve => setTimeout(resolve, delay)).then(() =>\r\n          this._doQuery(datasource, options, namespace, retryCount + 1)\r\n        );\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Checks whether an access token exist. If none exists or it is expired a new one will be fetched.\r\n   * In case an api key auth is used, this method will never fetch a token.\r\n   *\r\n   * @param datasource the datasource to use\r\n   */\r\n  static _authenticate(datasource: any) {\r\n    const {tokens} = datasource.instanceSettings;\r\n    const useApiKey = _.get(datasource.instanceSettings, 'jsonData.useApiKey', false);\r\n\r\n    // never aquire token in case of api key auth\r\n    if (useApiKey) {\r\n      return Promise.resolve(true);\r\n    }\r\n\r\n    const acquireToken = !tokens || Sensu._isTokenExpired(tokens);\r\n    if (acquireToken) {\r\n      return Sensu._acquireAccessToken(datasource);\r\n    } else {\r\n      return Promise.resolve(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns whether the given token is already expired.\r\n   *\r\n   * @param token the token to check\r\n   */\r\n  static _isTokenExpired(token: AccessToken) {\r\n    const timestampNow: number = Math.floor(Date.now() / 1000);\r\n    let expiresAt: number = token.expires_at;\r\n\r\n    if (token.expires_offset) {\r\n      expiresAt = expiresAt - token.expires_offset - Sensu.tokenExpireOffset_s;\r\n    }\r\n\r\n    return expiresAt < timestampNow;\r\n  }\r\n\r\n  /**\r\n   * Fetches and stores an access token.\r\n   *\r\n   * @param datasource the datasource to use\r\n   */\r\n  static _acquireAccessToken(datasource: any) {\r\n    return Sensu._request(datasource, 'GET', '/auth').then(result => {\r\n      const tokens: AccessToken = result.data;\r\n\r\n      const timestampNow: number = Math.floor(Date.now() / 1000);\r\n      const expiresOffset: number =\r\n        tokens.expires_at - timestampNow - Sensu.tokenTimeout_s;\r\n\r\n      tokens.expires_offset = expiresOffset;\r\n\r\n      datasource.instanceSettings.tokens = tokens;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes a (potential authenticated) request against the specified url using the given datasource (server) and HTTP method.\r\n   *\r\n   * @param datasource the datasource to use\r\n   * @param method the method of the HTTP request (GET, POST, ...)\r\n   * @param url the url to send the request to\r\n   */\r\n  static _request(\r\n    datasource: any,\r\n    method: string,\r\n    url: string,\r\n    requestParameters: Record<string, string> = {}\r\n  ) {\r\n    const useApiKey = _.get(datasource.instanceSettings, 'jsonData.useApiKey', false);\r\n\r\n    const req: any = {\r\n      method: method,\r\n    };\r\n\r\n    req.headers = {\r\n      'Content-Type': 'application/json',\r\n    };\r\n\r\n    if (useApiKey) {\r\n      // authentication via api key using authentication route\r\n      req.url = datasource.url + Sensu.apiKeyUrlPrefix + url;\r\n    } else {\r\n      // authentication via bearer token\r\n      req.url = datasource.url + url;\r\n\r\n      if (_.has(datasource.instanceSettings, 'tokens')) {\r\n        req.headers.Authorization =\r\n          'Bearer ' + datasource.instanceSettings.tokens.access_token;\r\n      }\r\n    }\r\n\r\n    req.params = requestParameters;\r\n\r\n    return datasource.backendSrv\r\n      .datasourceRequest(req)\r\n      .then(Sensu._handleRequestResult, Sensu._handleRequestError);\r\n  }\r\n\r\n  /**\r\n   * Is called when the request is ending successfully. In case of a 401 error, the request is not throwing an error but returning no result object.\r\n   *\r\n   * @param result the request's result object\r\n   */\r\n  static _handleRequestResult(result: any) {\r\n    if (result) {\r\n      return result;\r\n    } else {\r\n      throw {\r\n        message: 'Credentials Invalid: Could not logged in using credentials',\r\n        data: 'access_error',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Is called if the request's promise is getting an error.\r\n   *\r\n   * @param err the request's error object\r\n   */\r\n  static _handleRequestError(err: any) {\r\n    if (err.status !== 0 || err.status >= 300) {\r\n      if (err.data && err.data.message) {\r\n        throw {\r\n          message: 'Sensu Go Error: ' + err.data.message,\r\n          data: err.data,\r\n          config: err.config,\r\n        };\r\n      } else {\r\n        throw {\r\n          message: 'Network Error: ' + err.statusText + '(' + err.status + ')',\r\n          data: err.data,\r\n          config: err.config,\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an object which represents the request parameters that should be used\r\n   * by the request representing the data source query.\r\n   *\r\n   * @param options the query options to use as basis for the parameters\r\n   */\r\n  static _getParameters(options: QueryOptions) {\r\n    const {limit, responseFilters} = options;\r\n    const result: any = {};\r\n\r\n    // build the response filter parameters\r\n    const fieldSelector = this._buildFilterParameter(\r\n      responseFilters.filter(filter => filter.type === ServerSideFilterType.FIELD)\r\n    );\r\n    if (fieldSelector !== '') {\r\n      result.fieldSelector = fieldSelector;\r\n    }\r\n\r\n    const labelSelector = this._buildFilterParameter(\r\n      responseFilters.filter(filter => filter.type === ServerSideFilterType.LABEL)\r\n    );\r\n    if (labelSelector !== '') {\r\n      result.labelSelector = labelSelector;\r\n    }\r\n\r\n    // build the limit option\r\n    if (limit > 0) {\r\n      result.limit = limit;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates the parameter value for a response (server-side) filter. More details regarding its\r\n   * format can be found in the documentation: https://docs.sensu.io/sensu-go/latest/api/#response-filtering\r\n   *\r\n   * @param filters the filters which will be included in the filter parameter\r\n   */\r\n  static _buildFilterParameter(filters: ServerSideFilter[]) {\r\n    return _(filters)\r\n      .map(\r\n        filter =>\r\n          filter.key +\r\n          ' ' +\r\n          filter.matcher +\r\n          ' ' +\r\n          this._parseGrafanaMultiValue(filter.value)\r\n      )\r\n      .join(' && ');\r\n  }\r\n\r\n  /**\r\n   * Checks if the parameter value is a Grafana multi-value variable as specified in grafanaMultiValueRegex.\r\n   * If this is the case, the value is parsed to the sensu standard for set-based operators - i.E. (ABC|DEF|GHI)\r\n   * would be parsed into [ABC,DEF,GHI].\r\n   * Set-based operators are specified in https://docs.sensu.io/sensu-go/latest/api/#set-based-operators.\r\n   *\r\n   * @param expression the expression to be parsed.\r\n   * @returns a multi-value expression that complies to the touples specified in https://docs.sensu.io/sensu-go/latest/api/#set-based-operators.\r\n   */\r\n  static _parseGrafanaMultiValue(filterValue: string) {\r\n    if (this.grafanaMultiValueRegex.test(filterValue)) {\r\n      filterValue = filterValue\r\n        .replace(/\\(/g, '[')\r\n        .replace(/\\)/g, ']')\r\n        .replace(/\\|/g, ',');\r\n    }\r\n    return filterValue;\r\n  }\r\n}\r\n","import {AggregationType, ApiEndpoint, TextValue} from './types';\r\n\r\n/**\r\n * The default limit.\r\n */\r\nexport const DEFAULT_LIMIT = 100;\r\n\r\n/**\r\n * The default limit for aggregation queries.\r\n */\r\nexport const DEFAULT_AGGREGATION_LIMIT = 0;\r\n\r\n/**\r\n * Supported aggregation functions.\r\n */\r\nexport const AGGREGATION_TYPES = <AggregationType[]>[\r\n  {\r\n    value: 'count',\r\n    text: 'Count',\r\n    requiresTarget: false,\r\n  },\r\n  {\r\n    value: 'sum',\r\n    text: 'Sum',\r\n    requiresTarget: true,\r\n  },\r\n];\r\n\r\n/**\r\n * Sensu API endpoints.\r\n */\r\nexport const API_ENDPOINTS = <ApiEndpoint[]>[\r\n  {\r\n    text: 'Entity API',\r\n    value: 'entity',\r\n    url: '/entities',\r\n    fieldSelectors: [\r\n      // defined by the response filter feature (see: https://docs.sensu.io/sensu-go/latest/api/#response-filtering)\r\n      'entity.name',\r\n      'entity.namespace',\r\n      'entity.deregister',\r\n      'entity.entity_class',\r\n      'entity.subscriptions',\r\n    ],\r\n  },\r\n  {\r\n    text: 'Events API',\r\n    value: 'events',\r\n    url: '/events',\r\n    fieldSelectors: [\r\n      'event.is_silenced',\r\n      'event.name',\r\n      'event.namespace',\r\n      'event.check.handlers',\r\n      'event.check.is_silenced',\r\n      'event.check.name',\r\n      'event.check.publish',\r\n      'event.check.round_robin',\r\n      'event.check.runtime_assets',\r\n      'event.check.status',\r\n      'event.check.subscriptions',\r\n      'event.entity.deregister',\r\n      'event.entity.entity_class',\r\n      'event.entity.name',\r\n      'event.entity.subscriptions',\r\n    ],\r\n  },\r\n  {\r\n    text: 'Namespaces API',\r\n    value: 'namespaces',\r\n    url: '/namespaces',\r\n    fieldSelectors: ['namespace.name'],\r\n  },\r\n];\r\n\r\n/**\r\n * Supported query types.\r\n */\r\nexport const QUERY_TYPES = <TextValue[]>[\r\n  {\r\n    value: 'field',\r\n    text: 'Field Selection',\r\n  },\r\n  {\r\n    value: 'aggregation',\r\n    text: 'Aggregation',\r\n  },\r\n];\r\n\r\n/**\r\n * Supported result data formats.\r\n */\r\nexport const FORMATS = <TextValue[]>[\r\n  {\r\n    value: 'table',\r\n    text: 'Table',\r\n  },\r\n  {\r\n    value: 'table-v',\r\n    text: 'Table (Vertical)',\r\n  },\r\n  {\r\n    value: 'series',\r\n    text: 'Time Series',\r\n  },\r\n];\r\n\r\n/**\r\n * Properties containing a timestamp and should converted (from seconds to miliseconds).\r\n */\r\nexport const TIME_PROPERTIES: string[] = [\r\n  'timestamp',\r\n  'check.executed',\r\n  'check.issued',\r\n  'check.last_ok',\r\n  'entity.last_seen',\r\n  'last_seen',\r\n];\r\n","import _ from 'lodash';\r\n\r\n/**\r\n * Returns whether the given data value matchs the filter specified by the filter value in combination with the given operator.\r\n * @param filterValue the filter value\r\n * @param operator the operator used for comparision\r\n * @param dataValue the data value to test\r\n */\r\nexport const matchs = (\r\n  filterValue: string,\r\n  operator: string,\r\n  dataValue: number | string | boolean\r\n): boolean => {\r\n  if (operator === '==') {\r\n    return filterValue == dataValue;\r\n  }\r\n  if (operator === '!=') {\r\n    return filterValue != dataValue;\r\n  }\r\n  if (operator === '=~' || operator === '!~') {\r\n    return _matchRegExp(filterValue, operator, dataValue);\r\n  }\r\n  if (operator === '<' || operator === '>') {\r\n    return _matchNumber(filterValue, operator, dataValue);\r\n  }\r\n\r\n  throw 'Unsupported operator \"' + operator + '\"';\r\n};\r\n\r\n/**\r\n * Matching using '>' and '<' operators.\r\n */\r\nconst _matchNumber = (filterValue: string, operator: string, dataValue: any) => {\r\n  const filterNumber = Number(filterValue);\r\n\r\n  if (!_.isFinite(filterNumber)) {\r\n    console.warn(\r\n      'The specified filter value (' +\r\n        filterValue +\r\n        ') is not compatible to filter on a numeric attribute.'\r\n    );\r\n    return false;\r\n  }\r\n\r\n  if (operator === '<') {\r\n    return dataValue < filterNumber;\r\n  } else {\r\n    return dataValue > filterNumber;\r\n  }\r\n};\r\n\r\n/**\r\n * Matching using regular expressions.\r\n */\r\nconst _matchRegExp = (filterValue: string, operator: string, dataValue: any) => {\r\n  const regex: RegExp = _stringToRegex(filterValue);\r\n\r\n  if (operator === '=~') {\r\n    return regex.test(dataValue);\r\n  } else {\r\n    return !regex.test(dataValue);\r\n  }\r\n};\r\n\r\n/**\r\n * Converts a string to a RegExp instance and keeps optional modifiers.\r\n * @param value the string to convert\r\n */\r\nconst _stringToRegex = (value: string) => {\r\n  const regex = value.match(/\\/(.*)\\/(\\w*)/);\r\n  if (regex) {\r\n    return new RegExp(regex[1], regex[2]);\r\n  } else {\r\n    return new RegExp(value);\r\n  }\r\n};\r\n\r\nexport default {matchs};\r\n","import _ from 'lodash';\r\nimport {DEFAULT_LIMIT, DEFAULT_AGGREGATION_LIMIT} from '../constants';\r\n\r\nimport {\r\n  QueryComponents,\r\n  GrafanaTarget,\r\n  ServerSideFilterType,\r\n  ServerSideFilter,\r\n  ClientSideFilter,\r\n} from '../types';\r\n\r\n/** RegEx matching a in-browser filter of the WHERE-clause. */\r\nconst CLIENT_FILTER_REG_EXP = '([^\\\\s:=!]+)\\\\s*(==|=~|!=|>|<|!~|=)\\\\s*(\\\\S+)';\r\n\r\n/** RegExp of a filter key or value of the server-side filter. */\r\nconst SERVER_FILTER_VALUE_REG_EXP = '\\\\[[^[]+\\\\]|\"[^\"]+\"|\\\\S+';\r\n\r\n/** RegEx matching a response filter (server-side) of the WHERE-clause. */\r\nconst SERVER_FILTER_REG_EXP =\r\n  '(fieldSelector|labelSelector):(' +\r\n  SERVER_FILTER_VALUE_REG_EXP +\r\n  ')\\\\s*(==|!=|IN|NOTIN|MATCHES)\\\\s*(' +\r\n  SERVER_FILTER_VALUE_REG_EXP +\r\n  ')';\r\n\r\n/** RegEx representing a single element of the WHERE-clause. */\r\nconst QUERY_SINGLE_FILTER_REG_EXP =\r\n  '(' + SERVER_FILTER_REG_EXP + '|' + CLIENT_FILTER_REG_EXP + ')';\r\n\r\n/** RegEx representing the whole query string. */\r\nconst QUERY_FULL_REG_EXP =\r\n  '^\\\\s*QUERY\\\\s+API\\\\s+(entity|events|namespaces)\\\\s+(IN\\\\s+NAMESPACE\\\\s+(\\\\S+)\\\\s+)?SELECT\\\\s+(\\\\S+)(\\\\s+WHERE\\\\s+(' +\r\n  QUERY_SINGLE_FILTER_REG_EXP +\r\n  '(\\\\s+AND\\\\s+' +\r\n  QUERY_SINGLE_FILTER_REG_EXP +\r\n  ')*))?(\\\\s+LIMIT\\\\s+(\\\\d+))?\\\\s*$';\r\n\r\n/**\r\n * Creates a query string based on the target definition.\r\n * @param target the data used by the query\r\n */\r\nexport function targetToQueryString(target: GrafanaTarget): string {\r\n  let query: string = 'QUERY API ' + target.apiEndpoints;\r\n\r\n  query += _namespace(target);\r\n\r\n  if (target.queryType === 'field') {\r\n    query += _queryTypeField(target);\r\n  } else if (target.queryType === 'aggregation') {\r\n    query += _queryTypeAggregation(target);\r\n  }\r\n\r\n  query += _whereClause(target);\r\n  query += _limit(target);\r\n\r\n  return query;\r\n}\r\n\r\n/**\r\n * Return the \"select\" statement based on the given target.\r\n * E.g.: SELECT field, another.field AS myField\r\n */\r\nconst _queryTypeField = (target: GrafanaTarget) => {\r\n  const fields = _(target.fieldSelectors)\r\n    .flatMap(selector => {\r\n      if (selector.alias) {\r\n        return selector.getPath() + ' AS ' + selector.alias;\r\n      } else {\r\n        return selector.getPath();\r\n      }\r\n    })\r\n    .join(', ');\r\n\r\n  return ' SELECT ' + fields;\r\n};\r\n\r\n/**\r\n * Return the \"aggregation\" statement based on the given target.\r\n * E.g.:  AGGREGATE sum ON field\r\n */\r\nconst _queryTypeAggregation = (target: GrafanaTarget) => {\r\n  let query: string = ' AGGREGATE ' + target.aggregationType;\r\n\r\n  if (target.aggregationRequiresTarget) {\r\n    query += ' ON ' + target.aggregationField;\r\n  }\r\n\r\n  return query;\r\n};\r\n\r\n/**\r\n * Return the namespace statement based on the given target.\r\n * E.g.:  IN NAMESPACE default\r\n */\r\nconst _namespace = (target: GrafanaTarget) => {\r\n  if (target.namespace === 'default') {\r\n    return '';\r\n  } else {\r\n    return ' IN NAMESPACE ' + target.namespace;\r\n  }\r\n};\r\n\r\n/**\r\n * Return the where clause based on the given target.\r\n * E.g.: WHERE field=value AND status>0\r\n */\r\nconst _whereClause = (target: GrafanaTarget) => {\r\n  const {clientSideFilters, serverSideFilters} = target;\r\n\r\n  const serverFilters = _(serverSideFilters)\r\n    .map(\r\n      filter =>\r\n        (filter.type == ServerSideFilterType.FIELD ? 'fieldSelector' : 'labelSelector') +\r\n        ':' +\r\n        filter.key +\r\n        ' ' +\r\n        filter.matcher.toUpperCase() +\r\n        ' ' +\r\n        filter.value\r\n    )\r\n    .value();\r\n\r\n  const clientFilters = _(clientSideFilters)\r\n    .map(filter => filter.key + ' ' + filter.matcher + ' ' + filter.value)\r\n    .value();\r\n\r\n  const whereClause = _([serverFilters, clientFilters])\r\n    .flatten()\r\n    .join(' AND ');\r\n\r\n  if (whereClause) {\r\n    return ' WHERE ' + whereClause;\r\n  } else {\r\n    return '';\r\n  }\r\n};\r\n\r\n/**\r\n * Return the limit statement based on the given target. If no limit is specified the default limit will be used.\r\n * E.g.: LIMIT 100\r\n */\r\nconst _limit = (target: GrafanaTarget) => {\r\n  let queryLimit: number;\r\n\r\n  if (target.limit) {\r\n    queryLimit = _.defaultTo(parseInt(target.limit), DEFAULT_LIMIT);\r\n  } else {\r\n    // Use a special default limit in aggregation queries\r\n    if (target.queryType === 'aggregation') {\r\n      queryLimit = DEFAULT_AGGREGATION_LIMIT;\r\n    } else {\r\n      queryLimit = DEFAULT_LIMIT;\r\n    }\r\n  }\r\n\r\n  if (queryLimit > 0) {\r\n    return ' LIMIT ' + queryLimit;\r\n  } else {\r\n    return '';\r\n  }\r\n};\r\n\r\nexport const extractQueryComponents = (query: string): QueryComponents | null => {\r\n  const queryRegExp = new RegExp(QUERY_FULL_REG_EXP, 'i');\r\n  const matchResult = query.match(queryRegExp);\r\n\r\n  if (!matchResult) {\r\n    return null;\r\n  }\r\n\r\n  let namespace: string;\r\n  if (matchResult[3] !== undefined) {\r\n    namespace = matchResult[3];\r\n  } else {\r\n    namespace = 'default';\r\n  }\r\n\r\n  const components: QueryComponents = {\r\n    apiKey: matchResult[1],\r\n    namespace: namespace,\r\n    selectedField: matchResult[4],\r\n    clientFilters: [],\r\n    serverFilters: [],\r\n    limit: parseInt(matchResult[25]),\r\n  };\r\n\r\n  if (matchResult[6] !== undefined) {\r\n    const filterRegExp = new RegExp(\r\n      SERVER_FILTER_REG_EXP + '|' + CLIENT_FILTER_REG_EXP,\r\n      'gi'\r\n    );\r\n\r\n    const whereClause: string = matchResult[6];\r\n\r\n    let match: RegExpExecArray | null;\r\n    while ((match = filterRegExp.exec(whereClause)) !== null) {\r\n      const isServerFilter = match[1] !== undefined;\r\n\r\n      if (isServerFilter) {\r\n        // add response filter\r\n        const filter: ServerSideFilter = {\r\n          type:\r\n            match[1] === 'fieldSelector'\r\n              ? ServerSideFilterType.FIELD\r\n              : ServerSideFilterType.LABEL,\r\n          key: match[2],\r\n          matcher: match[3],\r\n          value: match[4],\r\n        };\r\n\r\n        components.serverFilters.push(filter);\r\n      } else {\r\n        // add in-browser filter\r\n        const filter: ClientSideFilter = {\r\n          key: match[5],\r\n          matcher: match[6] === '=' ? '==' : match[6],\r\n          value: match[7],\r\n        };\r\n\r\n        components.clientFilters.push(filter);\r\n      }\r\n    }\r\n  }\r\n\r\n  return components;\r\n};\r\n\r\nexport default {targetToQueryString, extractQueryComponents};\r\n","import {DataPoint, GrafanaTable} from '../types';\r\nimport {TIME_PROPERTIES} from '../constants';\r\nimport _ from 'lodash';\r\nimport moment from 'moment';\r\n\r\n/**\r\n * Transforms the given data into a table representation.\r\n */\r\nconst transform = (dataMatrix: DataPoint[][], vertical: boolean): GrafanaTable => {\r\n  const columns = _extractColumns(dataMatrix);\r\n\r\n  // create column index mapping\r\n  const columnIndexMap = {};\r\n  _.each(columns, (column, index) => (columnIndexMap[column.text] = index));\r\n\r\n  // generate data rows\r\n  const rows: any[][] = _.map(dataMatrix, dataRow => {\r\n    const row = _.times(columns.length, _.constant(null));\r\n\r\n    _(dataRow)\r\n      .map(({name, value}) => {\r\n        if (_.isArray(value)) {\r\n          return _.map(value, (element, index) => [name + '[' + index + ']', element]);\r\n        } else {\r\n          return [[name, value]];\r\n        }\r\n      })\r\n      .flatten()\r\n      .map(data => {\r\n        if (_.isPlainObject(data[1]) || _.isArray(data[1])) {\r\n          data[1] = JSON.stringify(data[1]);\r\n        }\r\n        return data;\r\n      })\r\n      .each(([columnName, value]) => {\r\n        row[columnIndexMap[columnName]] = value;\r\n      });\r\n\r\n    return row;\r\n  });\r\n\r\n  if (vertical) {\r\n    return _asVerticalTable(columns, rows);\r\n  }\r\n\r\n  // create grafana result object\r\n  return <GrafanaTable>{\r\n    columns,\r\n    rows,\r\n    type: 'table',\r\n  };\r\n};\r\n\r\nconst _asVerticalTable = (dataColumns, dataRows: any[][]): GrafanaTable => {\r\n  // fixed table headers\r\n  const columns = [\r\n    {\r\n      text: 'Attribute',\r\n    },\r\n    {\r\n      text: 'Value',\r\n    },\r\n  ];\r\n\r\n  const rows = _(dataRows)\r\n    .flatten()\r\n    .map((value, idx) => [dataColumns[idx].text, value])\r\n    .value();\r\n\r\n  // this is done because users cannot define a time formatting based on rows\r\n  _convertTimestamps(rows);\r\n\r\n  return <GrafanaTable>{\r\n    columns,\r\n    rows,\r\n    type: 'table',\r\n  };\r\n};\r\n\r\nconst _convertTimestamps = (rows: any[][]) => {\r\n  _.each(rows, row => {\r\n    const attribute = row[0];\r\n    const value = row[1];\r\n\r\n    for (let index = 0; index < TIME_PROPERTIES.length; index++) {\r\n      if (attribute === TIME_PROPERTIES[index]) {\r\n        const time = _.defaultTo(value, -1);\r\n        if (time > 0) {\r\n          row[1] = moment(time).format('YYYY-MM-DD HH:mm:ss');\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Returns an array of columns which exist in the given data matrix. Each data point attribute will be\r\n * represents by a column.\r\n *\r\n * @param dataMatrix the data basis\r\n */\r\nconst _extractColumns = (dataMatrix: DataPoint[][]) => {\r\n  const isArrayMarker = {};\r\n\r\n  // extract existing columns\r\n  return _(dataMatrix)\r\n    .flatten()\r\n    .map(({name, value}) => {\r\n      if (_.isArray(value)) {\r\n        isArrayMarker[name] = true;\r\n        return _.times(value.length, index => name + '[' + index + ']');\r\n      } else {\r\n        if (_.isNil(value) && _.get(isArrayMarker, name, false)) {\r\n          return [];\r\n        }\r\n        return [name];\r\n      }\r\n    })\r\n    .flatten()\r\n    .uniq()\r\n    .map(name => {\r\n      return {\r\n        text: name,\r\n      };\r\n    })\r\n    .value();\r\n};\r\n\r\nexport default transform;\r\n","import {DataPoint, GrafanaTable, GrafanaTimeSeries} from '../types';\r\nimport table_transform from './table_transformer';\r\nimport timeseries_transform from './timeseries_transformer';\r\n\r\nexport default {\r\n  toTable: (dataMatrix: DataPoint[][], vertical: boolean): GrafanaTable => {\r\n    return table_transform(dataMatrix, vertical);\r\n  },\r\n  toTimeSeries: (dataMatrix: DataPoint[][]): GrafanaTimeSeries[] => {\r\n    return timeseries_transform(dataMatrix);\r\n  },\r\n};\r\n","import {DataPoint, GrafanaTimeSeries} from '../types';\r\nimport _ from 'lodash';\r\n\r\n/**\r\n * Transforms the given data into a time series representation.\r\n */\r\nconst transform = (dataMatrix: DataPoint[][]): GrafanaTimeSeries[] => {\r\n  const now: number = Date.now();\r\n\r\n  // maps the data to a series - skips all values which are not finite\r\n  // - name => series name\r\n  // - value => value\r\n  return _(dataMatrix)\r\n    .flatten()\r\n    .filter(data => _.isFinite(data.value))\r\n    .map(data => {\r\n      return <GrafanaTimeSeries>{\r\n        target: data.name,\r\n        datapoints: [[data.value, now]],\r\n      };\r\n    })\r\n    .value();\r\n};\r\n\r\nexport default transform;\r\n","import _ from 'lodash';\r\nimport {ClientSideFilter, GrafanaTarget} from '../types';\r\n\r\n/** The latest configuration version. */\r\nconst LATEST_VERSION = 2;\r\n\r\n/** Migrates the passed configuration target to the latest version. The passed object will be mutated. */\r\nconst migrate = (target: GrafanaTarget): GrafanaTarget => {\r\n  const {version} = target;\r\n\r\n  if (version === undefined) {\r\n    init(target);\r\n  }\r\n  if (version === 1) {\r\n    toVersion2(target);\r\n  }\r\n\r\n  return target;\r\n};\r\n\r\n/** Initializes the configuration target. */\r\nconst init = (target: GrafanaTarget) => {\r\n  target.version = LATEST_VERSION;\r\n  target.clientSideFilters = [];\r\n  target.serverSideFilters = [];\r\n};\r\n\r\n/** Migrates the passed configuration target from version 1 to version 2. */\r\nconst toVersion2 = (target: GrafanaTarget) => {\r\n  console.log('Migrating data source configuration to version 2.');\r\n\r\n  const {filterSegments} = target;\r\n\r\n  const filters = _(filterSegments)\r\n    .filter(segments => segments.length === 3)\r\n    .filter(segments => !_.get(segments[2], 'fake', false))\r\n    .map(segments => {\r\n      const matcher = segments[1].value === '=' ? '==' : segments[1].value;\r\n\r\n      return <ClientSideFilter>{\r\n        key: segments[0].value,\r\n        matcher,\r\n        value: segments[2].value,\r\n      };\r\n    })\r\n    .value();\r\n\r\n  delete target.filterSegments;\r\n\r\n  target.clientSideFilters = filters;\r\n  target.serverSideFilters = [];\r\n\r\n  target.version = 2;\r\n};\r\n\r\nexport default {\r\n  migrate,\r\n};\r\n","import _ from 'lodash';\r\nimport {DataPoint} from '../types';\r\n\r\n/**\r\n * Does a count aggregation. The number of elements in the given data is returned.\r\n *\r\n * @param data the data to aggregate\r\n * @param name  the name of the resulting value\r\n */\r\nconst count = (data: any[], name: string): DataPoint[] => {\r\n  return <DataPoint[]>[\r\n    {\r\n      name,\r\n      value: data.length,\r\n    },\r\n  ];\r\n};\r\n\r\n/**\r\n * Does a sum aggregation. The sum of the specified attribute of all elements in the given data is calculated.\r\n *\r\n * @param data  the data to aggregate\r\n * @param name the name of the resulting value\r\n * @param targetField  the field which should be summed up\r\n */\r\nconst sum = (\r\n  data: any[],\r\n  name: string,\r\n  targetField: string | undefined\r\n): DataPoint[] | null => {\r\n  if (!targetField) {\r\n    return [];\r\n  }\r\n\r\n  let sum: number | null = _.sumBy(data, targetField);\r\n\r\n  if (!_.isFinite(sum)) {\r\n    sum = null;\r\n  }\r\n\r\n  return <DataPoint[]>[\r\n    {\r\n      name,\r\n      value: sum,\r\n    },\r\n  ];\r\n};\r\n\r\nexport default {count, sum};\r\n","import _ from 'lodash';\n\nimport sensu from './sensu/sensu';\nimport {\n  API_ENDPOINTS,\n  DEFAULT_LIMIT,\n  DEFAULT_AGGREGATION_LIMIT,\n  TIME_PROPERTIES,\n} from './constants';\nimport FieldSelector from './FieldSelector';\nimport FilterUtils from './utils/datasource_filter_util';\nimport QueryUtils from './utils/query_util';\nimport transformer from './transformer';\nimport ConfigMigration from './utils/config_migration_util';\nimport AggregationUtils from './utils/data_aggregation_util';\n\nimport {\n  PreparedTarget,\n  ColumnMapping,\n  DataPoint,\n  ClientSideFilter,\n  QueryComponents,\n  InstanceSettings,\n  QueryOptions,\n  GrafanaTarget,\n} from './types';\n\nexport default class SensuDatasource {\n  url: string;\n\n  /** @ngInject */\n  constructor(\n    public instanceSettings: InstanceSettings,\n    public backendSrv,\n    private templateSrv\n  ) {\n    this.url = instanceSettings.url.trim();\n  }\n\n  /**\n   * Preprocces the query targets like resolving template variables.\n   */\n  prepareQuery = (target: GrafanaTarget, queryOptions) => {\n    // resolve API url\n    const apiUrl = this._getApiUrl(target);\n    // resolve filters\n    const clientFilters = _.cloneDeep(target.clientSideFilters);\n    const serverFilters = _.cloneDeep(target.serverSideFilters);\n\n    const preparedTarget: PreparedTarget = <PreparedTarget>{\n      apiUrl,\n      clientFilters,\n      serverFilters,\n      target: _.cloneDeep(target), //ensure modifications are not globally propagated\n    };\n\n    this._resolveTemplateVariables(preparedTarget, queryOptions);\n\n    return preparedTarget;\n  };\n\n  /**\n   * Resolves template variables in the given prepared target.\n   */\n  _resolveTemplateVariables = (preparedTarget: PreparedTarget, queryOptions) => {\n    const {target, clientFilters, serverFilters} = preparedTarget;\n\n    // resolve variables in namespaces\n    const namespaces: string[] = this.templateSrv\n      .replace(target.namespace, queryOptions.scopedVars, 'pipe')\n      .split('|');\n\n    target.namespaces = namespaces;\n\n    // resolve variables in filters\n    [clientFilters, serverFilters].forEach(filters =>\n      filters.forEach(filter => {\n        filter.key = this.templateSrv.replace(filter.key, queryOptions.scopedVars, 'csv');\n        filter.value = this.templateSrv.replace(\n          filter.value,\n          queryOptions.scopedVars,\n          'regex'\n        );\n      })\n    );\n  };\n\n  /**\n   * Returns the url of the API used by the given target.\n   */\n  _getApiUrl = (target: GrafanaTarget) => {\n    const apiEndpoint: any = _.find(API_ENDPOINTS, {value: target.apiEndpoints});\n    if (apiEndpoint) {\n      return apiEndpoint.url;\n    } else {\n      return API_ENDPOINTS[0].url;\n    }\n  };\n\n  /**\n   * Executes a query.\n   */\n  query(queryOptions) {\n    const queryTargets = _(queryOptions.targets)\n      .filter(target => !target.hide)\n      .map(ConfigMigration.migrate)\n      .map(target => this.prepareQuery(target, queryOptions))\n      .value();\n\n    // empty result in case there is no query defined\n    if (queryTargets.length === 0) {\n      return Promise.resolve({data: []});\n    }\n\n    const queries = queryTargets.map(prepTarget => {\n      const {\n        apiUrl,\n        clientFilters,\n        serverFilters,\n        target: {queryType, fieldSelectors, namespaces, limit},\n      } = prepTarget;\n\n      // verify and set correct limit\n      let parsedLimit: number = _.defaultTo(parseInt(limit || ''), -1);\n      if (parsedLimit < 0) {\n        if (queryType === 'aggregation') {\n          parsedLimit = DEFAULT_AGGREGATION_LIMIT;\n        } else {\n          parsedLimit = DEFAULT_LIMIT;\n        }\n      }\n\n      const queryOptions: QueryOptions = {\n        method: 'GET',\n        url: apiUrl,\n        namespaces,\n        limit: parsedLimit,\n        responseFilters: serverFilters,\n      };\n\n      return sensu\n        .query(this, queryOptions)\n        .then(this._timeCorrection)\n        .then(data => this._filterData(data, clientFilters))\n        .then(data => {\n          if (queryType === 'field') {\n            return this._queryFieldSelection(data, fieldSelectors);\n          } else if (queryType === 'aggregation') {\n            return this._queryGroupAndAggregate(data, prepTarget);\n          } else {\n            return [];\n          }\n        });\n    });\n\n    return Promise.all(queries).then((queryResults: any) => {\n      if (queryOptions.resultAsPlainArray) {\n        // return only values - e.g. for template variables\n        const result = _(queryResults)\n          .map(result => transformer.toTable(result, false))\n          .map(result => result.rows)\n          .flatten()\n          .flatten()\n          .filter()\n          .map(value => {\n            return {text: value};\n          })\n          .value();\n\n        return result;\n      } else {\n        const resultDataList: any[] = _.flatMap(queryResults, (queryResult, index) => {\n          const {target: {format}} = queryTargets[index];\n\n          if (format === 'series') {\n            // return time series format\n            return transformer.toTimeSeries(queryResult);\n          } else {\n            const isVertical = format === 'table-v';\n            // return table format\n            return transformer.toTable(queryResult, isVertical);\n          }\n        });\n\n        return {\n          data: resultDataList,\n        };\n      }\n    });\n  }\n\n  /**\n   * Converting the timestamps from seconds to miliseconds because Sensu's timestamp\n   * resolution is in seconds but Grafana uses miliseconds.\n   */\n  _timeCorrection = (data: any) => {\n    _.each(data, dataElement => {\n      // iterate over all time properties\n      _.each(TIME_PROPERTIES, property => {\n        // fetch the properties value\n        const time = _.get(dataElement, property, -1);\n        // in case a time is set, we multiply them by 1000 to get miliseconds.\n        // in case the time is 0, we'll remove it, otherwise Grafana will display the epoch's starting times\n        if (time > 0) {\n          _.set(dataElement, property, time * 1000);\n        } else {\n          _.unset(dataElement, property);\n        }\n      });\n    });\n    return data;\n  };\n\n  /**\n   * This function will group the given data (if specified in the PreparedTarget) and aggregate it accordingly.\n   *\n   * @param data the data to group and aggregate\n   * @param prepTarget the settings for the grouping and aggregation\n   */\n  _queryGroupAndAggregate = (data: any[], prepTarget: PreparedTarget) => {\n    const {\n      target: {\n        aggregationAlias: alias,\n        aggregationType: type,\n        format,\n        groupBy: groupAttribute,\n      },\n    } = prepTarget;\n    // the name of the result value (the metric name if timeseries format is used, otherwise the column header)\n    const name = alias ? alias : type || 'value';\n\n    if (!groupAttribute) {\n      // just aggregate without grouping\n      const aggregationResult = this._queryAggregation(data, name, prepTarget);\n      return [aggregationResult];\n    } else {\n      // first group the data..\n      const groups = _.groupBy(data, groupAttribute);\n\n      // ..then aggregate the individual groups\n      const groupResult = _(groups)\n        .map((dataGroup, groupKey) =>\n          this._queryAggregation(dataGroup, groupKey, prepTarget)\n        )\n        .value();\n\n      if ((format === 'table' || format === 'table-v') && groupResult) {\n        const {groupAlias} = prepTarget.target;\n        // we transform the groups into multiple columns in case the table format is used\n        return this._mergeTableAggregation(\n          groupResult,\n          groupAlias || groupAttribute,\n          name\n        );\n      } else {\n        return groupResult;\n      }\n    }\n  };\n\n  /**\n   * We merge the seperate aggregation result into a single one, thus we get a nicer visualization\n   * in the table panel, where the group-attribute and value have their own column.\n   */\n  _mergeTableAggregation = (\n    groupData: (DataPoint[] | null)[],\n    groupByAttribute: string,\n    alias: string\n  ) => {\n    return _(groupData)\n      .map(group => {\n        if (!group || group.length == 0) {\n          return null;\n        }\n        const point: DataPoint = group[0];\n        return [\n          {\n            name: groupByAttribute,\n            value: point.name,\n          },\n          {\n            name: alias,\n            value: point.value,\n          },\n        ];\n      })\n      .filter() // null values\n      .value();\n  };\n\n  /**\n   * Process the data if the query type is 'aggregation'.\n   */\n  _queryAggregation = (data: any[], name: string, prepTarget: PreparedTarget) => {\n    const {aggregationType: type} = prepTarget.target;\n\n    if (type === 'count') {\n      return AggregationUtils.count(data, name);\n    } else if (type === 'sum') {\n      const {aggregationField} = prepTarget.target;\n      return AggregationUtils.sum(data, name, aggregationField);\n    } else {\n      throw new Error('The aggreation type \"' + type + '\" is not supported.');\n    }\n  };\n\n  /**\n   * Process the data if the query type is 'field'.\n   */\n  _queryFieldSelection = (data: any, fieldSelectors: FieldSelector[]) => {\n    const columnMappings: ColumnMapping[] = this._extractColumnMappings(\n      data,\n      fieldSelectors\n    );\n\n    const resultData = _.map(data, dataElement => {\n      // extract selected data\n      return _.map(columnMappings, mapping => {\n        const value: any = _.get(dataElement, mapping.path);\n\n        return <DataPoint>{\n          name: mapping.alias,\n          value: value,\n        };\n      });\n    });\n\n    return resultData;\n  };\n\n  /**\n   * Creates a column mapping - which object attribute/path is related to which column.\n   */\n  _extractColumnMappings = (data: any, fieldSelectors: FieldSelector[]) => {\n    const result: ColumnMapping[] = _.flatMap(fieldSelectors, selector => {\n      const paths = _(data)\n        .map(dataElement => this.resolvePaths(selector, dataElement))\n        .flatMap()\n        .uniq()\n        .value();\n\n      if (selector.alias) {\n        if (paths.length > 1) {\n          // use the alias in combination with an index as column name\n          return _.map(paths, (path, index) => {\n            return <ColumnMapping>{\n              path: path,\n              alias: selector.alias + '.' + index,\n            };\n          });\n        } else {\n          // use the alias instead the path as column name\n          return _.map(paths, path => {\n            return <ColumnMapping>{\n              path: path,\n              alias: selector.alias,\n            };\n          });\n        }\n      } else {\n        // use the path itself as column name\n        return _.map(paths, path => {\n          return <ColumnMapping>{\n            path: path,\n            alias: path,\n          };\n        });\n      }\n    });\n\n    return result;\n  };\n\n  /**\n   * Returns a filtered representation of the given data.\n   */\n  _filterData = (data: any, filters: ClientSideFilter[]) => {\n    return _.filter(data, dataElement =>\n      _.every(filters, filter => this._matches(dataElement, filter))\n    );\n  };\n\n  /**\n   * Returns whether the given element matches the given filter.\n   */\n  _matches = (element: any, filter: ClientSideFilter) => {\n    const filterKey: string = filter.key;\n    const matcher: string = filter.matcher;\n    const filterValue: string = filter.value;\n\n    const elementValue: any = _.get(element, filterKey);\n\n    return FilterUtils.matchs(filterValue, matcher, elementValue);\n  };\n\n  /**\n   * Resolves all existing paths of the specified selector based on the given data.\n   * Example: if the selector is '*' all possible attibutes (including nested) will be returned.\n   */\n  resolvePaths = (selector: any, data: any) => {\n    let selection: any = data;\n    let lastSelector = '';\n    let basePath = '';\n\n    for (let i = 0; i < selector.fieldSegments.length; i++) {\n      const segment: any = selector.fieldSegments[i];\n      lastSelector = segment.value;\n\n      if (lastSelector !== '*') {\n        if (basePath === '') {\n          basePath = lastSelector;\n        } else {\n          basePath = basePath + '.' + lastSelector;\n        }\n        selection = _.get(selection, lastSelector);\n      }\n    }\n\n    if (lastSelector === '*') {\n      const paths = this._deepResolve(selection);\n      if (basePath === '') {\n        return paths;\n      } else {\n        return _.map(paths, path => basePath + '.' + path);\n      }\n    } else {\n      return [basePath];\n    }\n  };\n\n  _deepResolve = data => {\n    const keys: string[] = Object.keys(data);\n\n    return _.flatMap(keys, key => {\n      if (_.isPlainObject(data[key])) {\n        return _.map(this._deepResolve(data[key]), nestedKeys => {\n          return key + '.' + nestedKeys;\n        });\n      } else {\n        return key;\n      }\n    });\n  };\n\n  /**\n   * Executes a query based on the given query command which is a string representation of it.\n   */\n  metricFindQuery(query: string) {\n    return this._query(query);\n  }\n\n  /**\n   * Executes the given query command.\n   */\n  _query = (query: string) => {\n    const queryComponents = QueryUtils.extractQueryComponents(query);\n\n    if (queryComponents === null) {\n      return Promise.resolve([]);\n    }\n    const options: any = this._transformQueryComponentsToQueryOptions(queryComponents);\n    options.resultAsPlainArray = true;\n\n    return this.query(options);\n  };\n\n  /**\n   * Transforms the given query components into an options object which can be used by the `query(..)` function.\n   */\n  _transformQueryComponentsToQueryOptions = (queryComponents: QueryComponents) => {\n    const {\n      apiKey,\n      selectedField,\n      clientFilters,\n      serverFilters,\n      namespace,\n      limit,\n    } = queryComponents;\n\n    const options = {\n      targets: [\n        <GrafanaTarget>{\n          apiEndpoints: apiKey,\n          queryType: 'field',\n          namespace: namespace,\n          limit: _.isNaN(limit) ? null : new String(limit),\n          fieldSelectors: [\n            <FieldSelector>{\n              fieldSegments: [\n                {\n                  value: selectedField,\n                },\n              ],\n            },\n          ],\n          format: 'table',\n          clientSideFilters: clientFilters,\n          serverSideFilters: serverFilters,\n          version: 2,\n        },\n      ],\n    };\n\n    return options;\n  };\n\n  /**\n   * Used by the config UI to test a datasource.\n   */\n  testDatasource() {\n    const useApiKey = _.get(this.instanceSettings, 'jsonData.useApiKey', false);\n\n    // the /auth/test endpoint is only available for testing basic auth credentials\n    const testUrl = useApiKey ? '/api/core/v2/namespaces' : '/auth/test';\n\n    return sensu\n      ._request(this, 'GET', testUrl)\n      .then(() => {\n        return {\n          status: 'success',\n          message: 'Successfully connected against the Sensu Go API',\n        };\n      })\n      .catch(error => {\n        if (useApiKey && error.data === 'access_error') {\n          return {\n            status: 'error',\n            message: 'API Key Invalid: Could not logged in using API key',\n          };\n        }\n        return {status: 'error', message: error.message};\n      });\n  }\n}\n","import _ from 'lodash';\r\nimport {SensuQueryCtrl} from './query_ctrl';\r\n\r\n/**\r\n * Helper class for building field selectors.\r\n * This class should be refactored => no segments should be in `target` but directly in the query controller.\r\n */\r\nexport default class FieldSelector {\r\n  fieldSegments: any[];\r\n\r\n  fieldType: string;\r\n\r\n  attributePath: string;\r\n\r\n  alias: string;\r\n\r\n  /**\r\n   * Restores the segments based on the given parameters.\r\n   */\r\n  static restore = (ctrl: SensuQueryCtrl, segments: FieldSelector): FieldSelector => {\r\n    const path = _(segments.fieldSegments)\r\n      .map(segment => segment.value)\r\n      .join('.');\r\n\r\n    const selector: FieldSelector = new FieldSelector(ctrl, path);\r\n\r\n    selector.alias = segments.alias;\r\n\r\n    return selector;\r\n  };\r\n\r\n  constructor(ctrl: SensuQueryCtrl, initPath: string) {\r\n    this.fieldSegments = _.map(initPath.split('.'), path =>\r\n      ctrl.uiSegmentSrv.newKey(path)\r\n    );\r\n    this.refresh(ctrl);\r\n  }\r\n\r\n  /**\r\n   * Refreshes the selectors UI elements - if a segment changes its value.\r\n   */\r\n  refresh = (ctrl: SensuQueryCtrl): void => {\r\n    if (!ctrl.dataPreview || ctrl.dataPreview.length <= 0) {\r\n      return;\r\n    }\r\n    let selection = ctrl.dataPreview[0];\r\n\r\n    for (let i = 0; i < this.fieldSegments.length; i++) {\r\n      const segment: any = this.fieldSegments[i];\r\n      const value: string = segment.value;\r\n\r\n      if (selection) {\r\n        selection = _.get(selection, value);\r\n      }\r\n\r\n      if (value === '*') {\r\n        this.fieldSegments = this.fieldSegments.slice(0, i + 1);\r\n      }\r\n    }\r\n\r\n    if (selection === undefined) {\r\n      this.fieldType = 'undefined';\r\n    } else if (_.isPlainObject(selection)) {\r\n      this.fieldSegments.push(ctrl.uiSegmentSrv.newKey('*'));\r\n      this.fieldType = 'object';\r\n    } else if (_.isArray(selection)) {\r\n      this.fieldType = 'array';\r\n    } else if (typeof selection === 'number') {\r\n      this.fieldType = 'number';\r\n    } else {\r\n      this.fieldType = 'string';\r\n    }\r\n\r\n    this.attributePath = this.getPath();\r\n  };\r\n\r\n  /**\r\n   * Returns the current attribute path of this selector.\r\n   */\r\n  getPath = (): string => {\r\n    return _(this.fieldSegments)\r\n      .map(segment => segment.value)\r\n      .join('.');\r\n  };\r\n}\r\n","import appEvents from 'grafana/app/core/app_events';\nimport {QueryCtrl} from 'grafana/app/plugins/sdk';\nimport _ from 'lodash';\n\nimport {\n  ApiEndpoint,\n  AggregationType,\n  TextValue,\n  GrafanaTarget,\n  ClientSideFilter,\n  ServerSideFilter,\n  ServerSideFilterType,\n} from './types';\n\nimport FieldSelector from './FieldSelector';\nimport {AGGREGATION_TYPES, API_ENDPOINTS, QUERY_TYPES, FORMATS} from './constants';\nimport {targetToQueryString} from './utils/query_util';\nimport Sensu from './sensu/sensu';\nimport ConfigMigration from './utils/config_migration_util';\n\nexport class SensuQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  // Will be stored by Grafana\n  target: GrafanaTarget;\n\n  // Constants\n  readonly aggregationTypes: AggregationType[] = AGGREGATION_TYPES;\n  readonly queryTypes: TextValue[] = QUERY_TYPES;\n  readonly formats: TextValue[] = FORMATS;\n\n  segmentAggregationTarget: any;\n  dataPreview: any = {};\n  dataPreviewBuffer: any[] = [];\n\n  apiEndpoints: ApiEndpoint[] = API_ENDPOINTS; // used in the partial\n  addFieldSegment: any;\n  namespaceSegment: any;\n  groupBySegment: any;\n\n  clientFilterSegments: any[] = [];\n  serverFilterSegments: any[] = [];\n\n  /** @ngInject **/\n  constructor($scope, $injector, private $q, public uiSegmentSrv, private templateSrv) {\n    super($scope, $injector);\n\n    // Migrate existing configurations to the latest model version\n    ConfigMigration.migrate(this.target);\n\n    const {clientSideFilters, serverSideFilters} = <GrafanaTarget>this.target;\n\n    // restore client filter segments\n    _(clientSideFilters)\n      .map(this._createClientFilterSegments)\n      .each(segmentArray => this.clientFilterSegments.push(segmentArray));\n\n    this.clientFilterSegments.push([this.uiSegmentSrv.newPlusButton()]);\n\n    //restore server filter segments\n    _(serverSideFilters)\n      .map(this._createServerFilterSegments)\n      .each(segmentArray => this.serverFilterSegments.push(segmentArray));\n\n    this.serverFilterSegments.push([this.uiSegmentSrv.newPlusButton()]);\n\n    // create field selectors\n    if (this.target.fieldSelectors === undefined) {\n      this.target.fieldSelectors = [new FieldSelector(this, '*')];\n    } else {\n      this.target.fieldSelectors = _.map(this.target.fieldSelectors, selector =>\n        FieldSelector.restore(this, selector)\n      );\n    }\n\n    if (this.target.apiEndpoints === undefined) {\n      this.target.apiEndpoints = API_ENDPOINTS[0].value;\n    }\n\n    if (this.target.queryType === undefined) {\n      this.target.queryType = this.queryTypes[0].value;\n    }\n\n    if (this.target.format === undefined) {\n      this.target.format = this.formats[0].value;\n    }\n\n    this.addFieldSegment = this.uiSegmentSrv.newPlusButton();\n\n    if (this.target.aggregation !== undefined) {\n      delete this.target.aggregation;\n    }\n\n    if (this.target.aggregationType === undefined) {\n      this.target.aggregationType = AGGREGATION_TYPES[0].value;\n    }\n\n    if (this.target.aggregationRequiresTarget === undefined) {\n      this.target.aggregationRequiresTarget = AGGREGATION_TYPES[0].requiresTarget;\n    }\n\n    if (this.target.aggregationField === undefined) {\n      this.segmentAggregationTarget = this.uiSegmentSrv.newFake(\n        'select target attribute',\n        'value',\n        'query-segment-value'\n      );\n    } else {\n      this.segmentAggregationTarget = this.uiSegmentSrv.newSegment({\n        value: this.target.aggregationField,\n      });\n    }\n\n    if (this.target.groupBy === undefined) {\n      this.groupBySegment = this.uiSegmentSrv.newPlusButton();\n    } else {\n      this.groupBySegment = this.uiSegmentSrv.newSegment({\n        value: this.target.groupBy,\n      });\n    }\n\n    if (this.target.namespace === undefined) {\n      this.target.namespace = 'default';\n    }\n\n    this.namespaceSegment = this.uiSegmentSrv.newSegment({value: this.target.namespace});\n\n    appEvents.on('ds-request-response', this.onResponseReceived, $scope);\n    this.panelCtrl.events.on('refresh', this.onRefresh, $scope);\n    this.panelCtrl.events.on('data-received', this.onDataReceived, $scope);\n\n    this.panelCtrl.refresh();\n  }\n\n  /**\n   * Creates an array containg segments which represent a in-browser filter. The first segment represents the filter-key,\n   * the second the operator and the third the filter-value.\n   */\n  _createClientFilterSegments = (filter: ClientSideFilter) => {\n    const segmentArray = [\n      this.uiSegmentSrv.newKey(filter.key),\n      this.uiSegmentSrv.newOperator(filter.matcher),\n      this.uiSegmentSrv.newKeyValue(filter.value),\n    ];\n\n    return segmentArray;\n  };\n\n  /**\n   * Creates an array containg segments which represent a response filter (sever-side). The first segment represents the type\n   * of the filer (labelSelector or fieldSelector), the second the filter-key, the third the operator and the fourth the filter-value.\n   */\n  _createServerFilterSegments = (filter: ServerSideFilter) => {\n    const type =\n      filter.type === ServerSideFilterType.FIELD ? 'fieldSelector' : 'labelSelector';\n\n    const segmentArray = [\n      this.uiSegmentSrv.newCondition(type),\n      this.uiSegmentSrv.newKey(filter.key),\n      this.uiSegmentSrv.newOperator(filter.matcher),\n      this.uiSegmentSrv.newKeyValue(filter.value),\n    ];\n\n    return segmentArray;\n  };\n\n  /**\n   * Returns the currently selected aggregation type.\n   */\n  getCurrentAggregationType = () => {\n    return <AggregationType>_.find(AGGREGATION_TYPES, {\n      value: this.target.aggregationType,\n    });\n  };\n\n  /**\n   * Called if the aggregation field changes.\n   */\n  onAggregationFieldChange = () => {\n    this.target.aggregationField = this.segmentAggregationTarget.value;\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Called if the aggregation type changes.\n   */\n  onAggregationTypeChange = () => {\n    this.target.aggregationRequiresTarget = this.getCurrentAggregationType().requiresTarget;\n    this._resetAggregation();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Resets the aggregation options.\n   */\n  _resetAggregation = () => {\n    delete this.target.aggregationAlias;\n    delete this.target.aggregationField;\n\n    this.removeGroupBy();\n\n    this.segmentAggregationTarget = this.uiSegmentSrv.newFake(\n      'select target attribute',\n      'value',\n      'query-segment-value'\n    );\n  };\n\n  /**\n   * Returns selectable options (all existing keys) for the aggregation field segment.\n   */\n  getTargetOptions = () => {\n    const options: string[] = this.getAllDeepKeys();\n    const segments: any[] = _.map(options, option =>\n      this.uiSegmentSrv.newSegment({value: option})\n    );\n\n    return this.$q.when(segments);\n  };\n\n  /**\n   * Returns selectable options (all existing keys) for the group-by segment.\n   */\n  getGroupByOptions = () => {\n    const options: string[] = this.getAllDeepKeys();\n    const segments: any[] = _.map(options, option =>\n      this.uiSegmentSrv.newSegment({value: option})\n    );\n\n    return this.$q.when(segments);\n  };\n\n  /**\n   * Called when the user changes the groupBy attribute.\n   */\n  onGroupByChange = () => {\n    this.target.groupBy = this.groupBySegment.value;\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Removes the groupBy attribute.\n   */\n  removeGroupBy = () => {\n    this.groupBySegment = this.uiSegmentSrv.newPlusButton();\n    delete this.target.groupBy;\n    delete this.target.groupAlias;\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Returns selectable options for the namespace segment.\n   */\n  getNamespaceOptions = () => {\n    return Sensu.query(this.datasource, {\n      method: 'GET',\n      url: '/namespaces',\n      namespaces: [],\n      limit: 0,\n      responseFilters: [],\n    })\n      .then(result => {\n        // get existing namespaces based on query result\n        const namespaces = _.map(result, namespace => namespace.name);\n\n        // add all option\n        namespaces.unshift('*');\n\n        // add template variables\n        _.each(this.templateSrv.variables, variable =>\n          namespaces.unshift('$' + variable.name)\n        );\n\n        return _.map(namespaces, option => this.uiSegmentSrv.newSegment({value: option}));\n      })\n      .catch(() => {\n        return [];\n      });\n  };\n\n  /**\n   * Called of the namespace is changing.\n   */\n  onNamespaceChange = () => {\n    this.target.namespace = this.namespaceSegment.value;\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Resets the field and filter segments.\n   */\n  _reset = () => {\n    this.target.fieldSelectors = [new FieldSelector(this, '*')];\n    this.clientFilterSegments = [[this.uiSegmentSrv.newPlusButton()]];\n    this.serverFilterSegments = [[this.uiSegmentSrv.newPlusButton()]];\n    this._updateFilterTarget();\n  };\n\n  /**\n   * Called when the api is changing.\n   */\n  onApiChange = () => {\n    this._reset();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Called when the query type is changing.\n   */\n  onQueryTypeChange = () => {\n    this._resetAggregation();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Removes the filter at the given index.\n   */\n  removeFilter = (index: number, isServerFilter: boolean) => {\n    const targetArray = isServerFilter\n      ? this.serverFilterSegments\n      : this.clientFilterSegments;\n    targetArray.splice(index, 1);\n    this._updateFilterTarget();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Called when a filter is changing.\n   */\n  onFilterSegmentUpdate = (segment, parentIndex, index) => {\n    if (segment.type === 'plus-button') {\n      this._addClientFilterSegment(segment);\n      return;\n    }\n\n    if (index == 2) {\n      const segmentValue = segment.value;\n      if (/\\/.*\\/\\w*/.test(segmentValue)) {\n        this.clientFilterSegments[parentIndex][1] = this.uiSegmentSrv.newOperator('=~');\n      }\n    }\n\n    this._updateFilterTarget();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Adds a new in-browser filter.\n   */\n  _addClientFilterSegment = (sourceSegment: any) => {\n    const segmentArray: any[] = [\n      this.uiSegmentSrv.newKey(sourceSegment.value),\n      this.uiSegmentSrv.newOperator('=='),\n      this.uiSegmentSrv.newFake('select filter value', 'value', 'query-segment-value'),\n    ];\n\n    this.clientFilterSegments.pop();\n    this.clientFilterSegments.push(segmentArray);\n    this.clientFilterSegments.push([this.uiSegmentSrv.newPlusButton()]);\n  };\n\n  /**\n   * Adds a new response filter.\n   */\n  _addServerFilterSegment = (sourceSegment: any) => {\n    const segmentArray: any[] = [\n      this.uiSegmentSrv.newCondition(sourceSegment.value),\n      this.uiSegmentSrv.newFake('select filter key', 'value', 'query-segment-value'),\n      this.uiSegmentSrv.newOperator('=='),\n      this.uiSegmentSrv.newFake('select filter value', 'value', 'query-segment-value'),\n    ];\n\n    this.serverFilterSegments.pop();\n    this.serverFilterSegments.push(segmentArray);\n    this.serverFilterSegments.push([this.uiSegmentSrv.newPlusButton()]);\n  };\n\n  /**\n   * Called when a response filter configuration is changed.\n   *\n   * @param segment the segment which has been changed\n   */\n  onServerFilterSegmentUpdate = segment => {\n    if (segment.type === 'plus-button') {\n      this._addServerFilterSegment(segment);\n      return;\n    }\n\n    this._updateFilterTarget();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Returns selectable options for filter segments.\n   */\n  getFilterSegmentOptions = (segment, parentIndex, index) => {\n    let segments: any[] = [];\n\n    if (segment.type === 'operator') {\n      segments = this.uiSegmentSrv.newOperators(['==', '=~', '!=', '!~', '<', '>']);\n    } else if (this.dataPreview && this.dataPreview.length > 0) {\n      let options: string[] = [];\n      if (index === 0) {\n        options = this.getAllDeepKeys();\n      } else if (index === 2) {\n        const filterKey = this.clientFilterSegments[parentIndex][0].value;\n        options = _(this.dataPreview)\n          .map(data => _.get(data, filterKey))\n          .uniq()\n          .value();\n\n        _.each(this.templateSrv.variables, variable =>\n          options.unshift('/$' + variable.name + '/')\n        );\n      }\n      segments = _.map(options, option => this.uiSegmentSrv.newSegment(String(option)));\n    }\n\n    return this.$q.when(segments);\n  };\n\n  /**\n   * The segments which represents the specified filters will not be persisted and passed to the data source.\n   * Instead, an object is created which represents the filters which is passed to the data source and\n   * persisted by Grafana. Calling this method syncs the object (target) and updates its value to match the\n   * segments' values specified by the user.\n   */\n  _updateFilterTarget = () => {\n    const target = <GrafanaTarget>this.target;\n\n    // update client filters\n    const clientFilters = _(this.clientFilterSegments)\n      .filter(segmentArray => segmentArray.length === 3)\n      .filter(segmentArray => !segmentArray[2].fake)\n      .map(segmentArray => {\n        return <ClientSideFilter>{\n          key: segmentArray[0].value,\n          matcher: segmentArray[1].value,\n          value: segmentArray[2].value,\n        };\n      })\n      .value();\n\n    target.clientSideFilters = clientFilters;\n\n    // update server filters\n    const serverFilters = _(this.serverFilterSegments)\n      .filter(segmentArray => segmentArray.length === 4)\n      .filter(segmentArray => !segmentArray[1].fake && !segmentArray[3].fake)\n      .map(segmentArray => {\n        let type;\n        switch (segmentArray[0].value) {\n          case 'fieldSelector':\n            type = ServerSideFilterType.FIELD;\n            break;\n          case 'labelSelector':\n            type = ServerSideFilterType.LABEL;\n            break;\n          default:\n            return <ServerSideFilter>{};\n        }\n\n        return <ServerSideFilter>{\n          key: segmentArray[1].value,\n          matcher: segmentArray[2].value,\n          value: segmentArray[3].value,\n          type,\n        };\n      })\n      .filter(filter => filter.type !== undefined)\n      .value();\n\n    target.serverSideFilters = serverFilters;\n  };\n\n  /**\n   * Returns all existing keys of the current data preview.\n   */\n  getAllDeepKeys = () => {\n    return _.flatMap(this.combineKeys(this.dataPreview[0]), e => e);\n  };\n\n  /**\n   * Returns selectable options for the field segments.\n   */\n  getFieldSelectorOptions = (segment, parentIndex, index) => {\n    let segments: any[] = [];\n\n    if (this.dataPreview && this.dataPreview.length > 0) {\n      let options: string[] = [];\n\n      let currentSelection: any = this.dataPreview[0];\n\n      if (index > 0) {\n        for (let i = 0; i < index; i++) {\n          const fieldSegment = this.target.fieldSelectors[parentIndex].fieldSegments[i];\n          currentSelection = _.get(currentSelection, fieldSegment.value);\n        }\n      }\n\n      options = _.concat(options, ['*']);\n      options = _.concat(options, Object.keys(currentSelection));\n\n      options.sort();\n\n      segments = _.map(options, option => this.uiSegmentSrv.newSegment({value: option}));\n    }\n\n    return this.$q.when(segments);\n  };\n\n  /**\n   * Called if a field segment is changed.\n   */\n  onFieldSelectorSegmentUpdate = (segment, parentIndex) => {\n    if (segment == this.addFieldSegment) {\n      this.target.fieldSelectors.push(new FieldSelector(this, segment.value));\n      this.addFieldSegment = this.uiSegmentSrv.newPlusButton();\n    } else {\n      this.target.fieldSelectors[parentIndex].refresh(this);\n    }\n\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Removes the field selector on the specified index.\n   */\n  removeField = index => {\n    this.target.fieldSelectors.splice(index, 1);\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Called if an alias is changing.\n   */\n  onAliasChange = () => {\n    this.panelCtrl.refresh();\n  };\n\n  combineKeys = object => {\n    const keys: string[] = Object.keys(object);\n\n    return _.flatMap(keys, key => {\n      if (_.isPlainObject(object[key])) {\n        return _.map(this.combineKeys(object[key]), nestedKeys => {\n          return key + '.' + nestedKeys;\n        });\n      } else {\n        return key;\n      }\n    });\n  };\n\n  /**\n   * Returns the currently selected api endpoint.\n   */\n  _getCurrentApi = () => {\n    return _.find(API_ENDPOINTS, {value: this.target.apiEndpoints});\n  };\n\n  getServerFilterOptions = (segment, parentIndex) => {\n    if (segment.type === 'operator') {\n      return this.$q.when(\n        this.uiSegmentSrv.newOperators(['==', '!=', 'in', 'notin', 'matches'])\n      );\n    } else if (segment.type === 'plus-button' || segment.type === 'condition') {\n      return this.$q.when(\n        _.map(['fieldSelector', 'labelSelector'], value =>\n          this.uiSegmentSrv.newSegment({value})\n        )\n      );\n    }\n\n    const options: string[] = _.map(\n      this.templateSrv.variables,\n      variable => '\"$' + variable.name + '\"'\n    );\n\n    const filterType = this.serverFilterSegments[parentIndex][0].value;\n\n    if (filterType === 'fieldSelector') {\n      const currentApi = this._getCurrentApi();\n      if (currentApi) {\n        currentApi.fieldSelectors.forEach(field => options.push(field));\n      }\n    }\n\n    const segments = _.map(options, option =>\n      this.uiSegmentSrv.newSegment(new String(option))\n    );\n\n    return this.$q.when(segments);\n  };\n\n  onDataReceived = () => {\n    if (this.dataPreviewBuffer.length > 0) {\n      // this is done so that we get the response from all querys. otherwise the last query could override the\n      // data which we need\n      //\n      // TODO only store the data related to the current query\n      this.dataPreview = _.flatten(this.dataPreviewBuffer);\n      this.dataPreviewBuffer = [];\n    }\n  };\n\n  /**\n   * Called when a request is finished. The requests data is stored and used as a data preview which is basis for auto completions.\n   */\n  onResponseReceived = response => {\n    if (!response.config.url.endsWith('/auth')) {\n      this.dataPreviewBuffer.push(response.data);\n    }\n  };\n\n  onRefresh = () => {\n    //TODO\n    this.dataPreview = {};\n  };\n\n  /**\n   * Returns a string representation of the current query configuration.\n   */\n  getCollapsedText() {\n    return targetToQueryString(this.target);\n  }\n}\n","import {InstanceSettings} from './types';\r\n\r\n/**\r\n * Controller responsible for the configuration ui.\r\n */\r\nexport class SensuConfigCtrl {\r\n  static templateUrl = 'partials/config.html';\r\n\r\n  // the current datasource settings\r\n  current: InstanceSettings;\r\n\r\n  /** @ngInject **/\r\n  constructor($scope) {\r\n    $scope.$watch(\r\n      () => this.current.url,\r\n      value => (this.current.jsonData.currentUrl = value)\r\n    );\r\n    $scope.$watch(\r\n      () => this.current.basicAuth,\r\n      value => {\r\n        if (value) {\r\n          this.current.jsonData.useApiKey = false;\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * When the \"Use API Key\" option is toggled.\r\n   */\r\n  onUseApiKeyToggle = () => {\r\n    const current = this.current;\r\n    if (current.jsonData.useApiKey) {\r\n      current.basicAuth = false;\r\n      this.resetApiKey();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Resets the currely set API key.\r\n   */\r\n  resetApiKey = () => {\r\n    this.current.secureJsonFields.apiKey = false;\r\n    this.current.secureJsonData = this.current.secureJsonData || {};\r\n    this.current.secureJsonData.apiKey = '';\r\n  };\r\n}\r\n"],"sourceRoot":""}