{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///external \"moment\"","webpack:///external \"app/core/app_events\"","webpack:///external \"app/plugins/sdk\"","webpack:///./types.ts","webpack:///./sensu/sensu.ts","webpack:///./constants.ts","webpack:///./utils/datasource_filter_util.ts","webpack:///./utils/query_util.ts","webpack:///./transformer/table_transformer.ts","webpack:///./transformer/index.ts","webpack:///./transformer/timeseries_transformer.ts","webpack:///./utils/config_migration_util.ts","webpack:///./datasource.ts","webpack:///./utils/data_aggregation_util.ts","webpack:///./FieldSelector.ts","webpack:///./query_ctrl.ts","webpack:///./config_ctrl.ts"],"names":["installedModules","__webpack_require__","m","module","exports","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__3__","ServerSideFilterType","FIELD","LABEL","query","datasource","options","namespaces","isEmpty","url","push","queries","map","namespace","_doQuery","Promise","all","then","data","flatten","retryCount","fullUrl","method","Sensu","apiBaseUrl","requestParameters","this","_getParameters","_authenticate","_request","result","catch","error","instanceSettings","tokens","delay","Math","floor","random","resolve","setTimeout","get","_isTokenExpired","_acquireAccessToken","token","timestampNow","Date","now","expiresAt","expires_at","expires_offset","tokenExpireOffset_s","expiresOffset","tokenTimeout_s","req","apiKeyUrlPrefix","has","headers","Authorization","access_token","params","backendSrv","datasourceRequest","_handleRequestResult","_handleRequestError","message","err","status","config","statusText","limit","responseFilters","fieldSelector","_buildFilterParameter","filter","type","labelSelector","filters","key","matcher","t","_parseGrafanaMultiValue","value","join","filterValue","grafanaMultiValueRegex","test","replace","RegExp","AGGREGATION_TYPES","text","requiresTarget","API_ENDPOINTS","fieldSelectors","QUERY_TYPES","FORMATS","TIME_PROPERTIES","operator","dataValue","regex","match","_stringToRegex","filterNumber","Number","isFinite","console","warn","SERVER_FILTER_REG_EXP","SERVER_FILTER_VALUE_REG_EXP","dataMatrix","vertical","isArrayMarker","columns","name","isArray","times","length","index","isNil","uniq","columnIndexMap","each","column","dataColumns","rows","dataRow","row","constant","element","isPlainObject","JSON","stringify","columnName","dataRows","attribute","time","defaultTo","format","_convertTimestamps","idx","target","datapoints","version","clientSideFilters","serverSideFilters","log","filterSegments","segments","cloneDeep","apiEndpoint","e","groupData","group","targetField","sum","sumBy","r","mapping","selector","fieldSegments","basePath","queryComponents","queryRegExp","matchResult","components","apiKey","selectedField","clientFilters","serverFilters","parseInt","filterRegExp","whereClause","exec","parsedLimit","selection","apiEndpoints","queryType","flatMap","alias","getPath","aggregationType","aggregationRequiresTarget","aggregationField","toUpperCase","queryLimit","a","uiSegmentSrv","newKey","segment","sourceSegment","clientFilterSegments","newFake","serverFilterSegments","o","segmentArray","l","addFieldSegment","currentApi","response","aggregation","panelCtrl","current","c","d","getter","Object","defineProperty","enumerable","Symbol","toStringTag","mode","__esModule","ns","create","bind","n","object","property","prototype","hasOwnProperty","call","p","s","moduleId","i","modules"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","import FieldSelector from './FieldSelector';\r\n\r\nexport interface AggregationType {\r\n  readonly value: string;\r\n  readonly text: string;\r\n  readonly requiresTarget: boolean;\r\n}\r\n\r\nexport interface ApiEndpoint {\r\n  readonly text: string;\r\n  readonly value: string;\r\n  readonly url: string;\r\n  readonly fieldSelectors: string[];\r\n}\r\n\r\nexport interface ColumnMapping {\r\n  path: string;\r\n  alias: string;\r\n}\r\n\r\nexport interface DataPoint {\r\n  readonly value: any;\r\n  readonly name: string;\r\n}\r\n\r\nexport interface BaseFilter {\r\n  key: string;\r\n  value: string;\r\n  matcher: string;\r\n}\r\n\r\nexport type ClientSideFilter = BaseFilter;\r\n\r\nexport interface ServerSideFilter extends BaseFilter {\r\n  type: ServerSideFilterType;\r\n}\r\n\r\nexport enum ServerSideFilterType {\r\n  FIELD = 0,\r\n  LABEL = 1,\r\n}\r\n\r\nexport interface InstanceSettings {\r\n  // the datasource url\r\n  url: string;\r\n\r\n  // whether basic auth is used\r\n  basicAuth: boolean;\r\n\r\n  // additional data\r\n  jsonData: JsonData;\r\n\r\n  // additional secured data\r\n  secureJsonData: SecureJsonData;\r\n\r\n  // map defining which secured data element is set\r\n  secureJsonFields: SecureJsonFields;\r\n}\r\n\r\nexport interface JsonData {\r\n  // copy of the current datasource url - used for dynamic routing\r\n  currentUrl: string;\r\n\r\n  // whether an API key should be used\r\n  useApiKey: boolean;\r\n}\r\n\r\nexport interface SecureJsonData {\r\n  // the specified API key\r\n  apiKey?: string;\r\n}\r\n\r\nexport interface SecureJsonFields {\r\n  // whether an API key has been stored by Grafana\r\n  apiKey?: boolean;\r\n}\r\n\r\nexport interface PreparedTarget {\r\n  readonly apiUrl: string;\r\n  readonly clientFilters: ClientSideFilter[];\r\n  readonly serverFilters: ServerSideFilter[];\r\n  readonly target: GrafanaTarget;\r\n}\r\n\r\nexport interface QueryComponents {\r\n  readonly apiKey: string;\r\n  readonly namespace: string;\r\n  readonly selectedField: string;\r\n  readonly clientFilters: ClientSideFilter[];\r\n  readonly serverFilters: ServerSideFilter[];\r\n  readonly limit: number;\r\n}\r\n\r\nexport interface TextValue {\r\n  readonly text: string;\r\n  readonly value: string;\r\n}\r\n\r\nexport interface QueryOptions {\r\n  method: string;\r\n  url: string;\r\n  namespaces: string[];\r\n  limit: number;\r\n  forceAccessTokenRefresh?: boolean;\r\n  responseFilters: ServerSideFilter[];\r\n}\r\n\r\nexport interface AccessToken {\r\n  readonly access_token: string;\r\n  readonly expires_at: number;\r\n  readonly refresh_token: string;\r\n  expires_offset?: number;\r\n}\r\n\r\nexport interface GrafanaTarget {\r\n  /** @deprecated */\r\n  filterSegments?: any[];\r\n  /** @deprecated */\r\n  aggregation?: string;\r\n\r\n  aggregationAlias?: string;\r\n  aggregationField?: string;\r\n  aggregationRequiresTarget?: boolean;\r\n  aggregationType?: string;\r\n  apiEndpoints: string;\r\n  fieldSelectors: FieldSelector[];\r\n  format: string;\r\n  groupAlias?: string;\r\n  groupBy?: string;\r\n  limit?: string;\r\n  namespace: string;\r\n  namespaces: string[]; // splitted and resolved namespace attribute\r\n  queryType: string;\r\n  refId: string;\r\n\r\n  version: number;\r\n  clientSideFilters: ClientSideFilter[];\r\n  serverSideFilters: ServerSideFilter[];\r\n}\r\n\r\nexport interface GrafanaUiSegment {\r\n  value: string;\r\n}\r\n\r\nexport interface GrafanaTimeSeries {\r\n  target: string; // time series name\r\n  datapoints: unknown[];\r\n}\r\n\r\nexport interface GrafanaTable {\r\n  columns: unknown[];\r\n  rows: unknown[][];\r\n  type: string;\r\n}","import _ from 'lodash';\r\nimport {\r\n  AccessToken,\r\n  QueryOptions,\r\n  ServerSideFilter,\r\n  ServerSideFilterType,\r\n} from '../types';\r\n\r\n/**\r\n * Class which encapsulates the query mechanism against the Sensu Go API.\r\n */\r\nexport default class Sensu {\r\n  /**\r\n   * The max duration a token is valid in seconds.\r\n   */\r\n  static readonly tokenTimeout_s = 600;\r\n  /**\r\n   * This duration will be susbtracted of the `tokenTimeout_s` duration.\r\n   */\r\n  static readonly tokenExpireOffset_s = 60;\r\n  /**\r\n   * The API's base url.\r\n   */\r\n  static readonly apiBaseUrl = '/api/core/v2';\r\n\r\n  /**\r\n   * The data source route used for API key authentication. See also the plugin.json file.\r\n   */\r\n  static readonly apiKeyUrlPrefix = '/api_key_auth';\r\n\r\n  /**\r\n   * Regex pattern for recognizing multi-values from Grafana template variables such as (ABC|DEF|GHI).\r\n   */\r\n  static readonly grafanaMultiValueRegex = new RegExp('^\\s*[(].*[|].*[)]\\s*$');\r\n\r\n  /**\r\n   * Executes a query against the given datasource. An access token will be gathered if needed.\r\n   * For each namespace specified in the passed options, a separate query will be executed.\r\n   *\r\n   * @param datasource the datasource to use\r\n   * @param options the options specifying the query's request\r\n   */\r\n  static query(datasource: any, options: QueryOptions) {\r\n    const {namespaces} = options;\r\n\r\n    if (_.isEmpty(namespaces) && options.url === '/namespaces') {\r\n      namespaces.push(''); // dummy element to execute a query\r\n    }\r\n\r\n    const queries = _.map(namespaces, namespace =>\r\n      this._doQuery(datasource, options, namespace)\r\n    );\r\n\r\n    return Promise.all(queries).then(data => {\r\n      return _.flatten(data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes a query against the given datasource. An access token will be gathered if needed.\r\n   *\r\n   * @param datasource the datasource to use\r\n   * @param options the options specifying the query's request\r\n   * @param namespace the namespace used by this query\r\n   */\r\n  static _doQuery(\r\n    datasource: any,\r\n    options: QueryOptions,\r\n    namespace: string,\r\n    retryCount = 0\r\n  ) {\r\n    const {method, url} = options;\r\n\r\n    let fullUrl: string;\r\n    if (url === '/namespaces') {\r\n      fullUrl = Sensu.apiBaseUrl + '/namespaces';\r\n    } else {\r\n      const namespacePath = namespace === '*' ? '' : '/namespaces/' + namespace;\r\n      fullUrl = Sensu.apiBaseUrl + namespacePath + url;\r\n    }\r\n\r\n    const requestParameters = this._getParameters(options);\r\n\r\n    return Sensu._authenticate(datasource)\r\n      .then(() => Sensu._request(datasource, method, fullUrl, requestParameters))\r\n      .then(result => result.data)\r\n      .catch(error => {\r\n        // we'll retry once\r\n        if (retryCount >= 1) {\r\n          throw error;\r\n        }\r\n\r\n        // delete token details in order to refresh the token in case of basic auth\r\n        delete datasource.instanceSettings.tokens;\r\n\r\n        // the retry is not immediatly done in order to prevent some race conditions\r\n        const delay = Math.floor(1000 + Math.random() * 1000);\r\n\r\n        return new Promise(resolve => setTimeout(resolve, delay)).then(() =>\r\n          this._doQuery(datasource, options, namespace, retryCount + 1)\r\n        );\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Checks whether an access token exist. If none exists or it is expired a new one will be fetched.\r\n   * In case an api key auth is used, this method will never fetch a token.\r\n   *\r\n   * @param datasource the datasource to use\r\n   */\r\n  static _authenticate(datasource: any) {\r\n    const {tokens} = datasource.instanceSettings;\r\n    const useApiKey = _.get(datasource.instanceSettings, 'jsonData.useApiKey', false);\r\n\r\n    // never aquire token in case of api key auth\r\n    if (useApiKey) {\r\n      return Promise.resolve(true);\r\n    }\r\n\r\n    const acquireToken = !tokens || Sensu._isTokenExpired(tokens);\r\n    if (acquireToken) {\r\n      return Sensu._acquireAccessToken(datasource);\r\n    } else {\r\n      return Promise.resolve(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns whether the given token is already expired.\r\n   *\r\n   * @param token the token to check\r\n   */\r\n  static _isTokenExpired(token: AccessToken) {\r\n    const timestampNow: number = Math.floor(Date.now() / 1000);\r\n    let expiresAt: number = token.expires_at;\r\n\r\n    if (token.expires_offset) {\r\n      expiresAt = expiresAt - token.expires_offset - Sensu.tokenExpireOffset_s;\r\n    }\r\n\r\n    return expiresAt < timestampNow;\r\n  }\r\n\r\n  /**\r\n   * Fetches and stores an access token.\r\n   *\r\n   * @param datasource the datasource to use\r\n   */\r\n  static _acquireAccessToken(datasource: any) {\r\n    return Sensu._request(datasource, 'GET', '/auth').then(result => {\r\n      const tokens: AccessToken = result.data;\r\n\r\n      const timestampNow: number = Math.floor(Date.now() / 1000);\r\n      const expiresOffset: number =\r\n        tokens.expires_at - timestampNow - Sensu.tokenTimeout_s;\r\n\r\n      tokens.expires_offset = expiresOffset;\r\n\r\n      datasource.instanceSettings.tokens = tokens;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes a (potential authenticated) request against the specified url using the given datasource (server) and HTTP method.\r\n   *\r\n   * @param datasource the datasource to use\r\n   * @param method the method of the HTTP request (GET, POST, ...)\r\n   * @param url the url to send the request to\r\n   */\r\n  static _request(\r\n    datasource: any,\r\n    method: string,\r\n    url: string,\r\n    requestParameters: Record<string, string> = {}\r\n  ) {\r\n    const useApiKey = _.get(datasource.instanceSettings, 'jsonData.useApiKey', false);\r\n\r\n    const req: any = {\r\n      method: method,\r\n    };\r\n\r\n    req.headers = {\r\n      'Content-Type': 'application/json',\r\n    };\r\n\r\n    if (useApiKey) {\r\n      // authentication via api key using authentication route\r\n      req.url = datasource.url + Sensu.apiKeyUrlPrefix + url;\r\n    } else {\r\n      // authentication via bearer token\r\n      req.url = datasource.url + url;\r\n\r\n      if (_.has(datasource.instanceSettings, 'tokens')) {\r\n        req.headers.Authorization =\r\n          'Bearer ' + datasource.instanceSettings.tokens.access_token;\r\n      }\r\n    }\r\n\r\n    req.params = requestParameters;\r\n\r\n    return datasource.backendSrv\r\n      .datasourceRequest(req)\r\n      .then(Sensu._handleRequestResult, Sensu._handleRequestError);\r\n  }\r\n\r\n  /**\r\n   * Is called when the request is ending successfully. In case of a 401 error, the request is not throwing an error but returning no result object.\r\n   *\r\n   * @param result the request's result object\r\n   */\r\n  static _handleRequestResult(result: any) {\r\n    if (result) {\r\n      return result;\r\n    } else {\r\n      throw {\r\n        message: 'Credentials Invalid: Could not logged in using credentials',\r\n        data: 'access_error',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Is called if the request's promise is getting an error.\r\n   *\r\n   * @param err the request's error object\r\n   */\r\n  static _handleRequestError(err: any) {\r\n    if (err.status !== 0 || err.status >= 300) {\r\n      if (err.data && err.data.message) {\r\n        throw {\r\n          message: 'Sensu Go Error: ' + err.data.message,\r\n          data: err.data,\r\n          config: err.config,\r\n        };\r\n      } else {\r\n        throw {\r\n          message: 'Network Error: ' + err.statusText + '(' + err.status + ')',\r\n          data: err.data,\r\n          config: err.config,\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an object which represents the request parameters that should be used\r\n   * by the request representing the data source query.\r\n   *\r\n   * @param options the query options to use as basis for the parameters\r\n   */\r\n  static _getParameters(options: QueryOptions) {\r\n    const {limit, responseFilters} = options;\r\n    const result: any = {};\r\n\r\n    // build the response filter parameters\r\n    const fieldSelector = this._buildFilterParameter(\r\n      responseFilters.filter(filter => filter.type === ServerSideFilterType.FIELD)\r\n    );\r\n    if (fieldSelector !== '') {\r\n      result.fieldSelector = fieldSelector;\r\n    }\r\n\r\n    const labelSelector = this._buildFilterParameter(\r\n      responseFilters.filter(filter => filter.type === ServerSideFilterType.LABEL)\r\n    );\r\n    if (labelSelector !== '') {\r\n      result.labelSelector = labelSelector;\r\n    }\r\n\r\n    // build the limit option\r\n    if (limit > 0) {\r\n      result.limit = limit;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates the parameter value for a response (server-side) filter. More details regarding its\r\n   * format can be found in the documentation: https://docs.sensu.io/sensu-go/latest/api/#response-filtering\r\n   *\r\n   * @param filters the filters which will be included in the filter parameter\r\n   */\r\n  static _buildFilterParameter(filters: ServerSideFilter[]) {\r\n    return _(filters)\r\n      .map(\r\n        filter =>\r\n          filter.key +\r\n          ' ' +\r\n          filter.matcher +\r\n          ' ' +\r\n          this._parseGrafanaMultiValue(filter.value)\r\n      )\r\n      .join(' && ');\r\n  }\r\n\r\n  /**\r\n   * Checks if the parameter value is a Grafana multi-value variable as specified in grafanaMultiValueRegex.\r\n   * If this is the case, the value is parsed to the sensu standard for set-based operators - i.E. (ABC|DEF|GHI)\r\n   * would be parsed into [ABC,DEF,GHI].\r\n   * Set-based operators are specified in https://docs.sensu.io/sensu-go/latest/api/#set-based-operators.\r\n   *\r\n   * @param expression the expression to be parsed.\r\n   * @returns a multi-value expression that complies to the touples specified in https://docs.sensu.io/sensu-go/latest/api/#set-based-operators.\r\n   */\r\n  static _parseGrafanaMultiValue(filterValue: string) {\r\n    if (this.grafanaMultiValueRegex.test(filterValue)) {\r\n      filterValue = filterValue.replace(/\\(/g, '[').replace(/\\)/g, ']').replace(/\\|/g, ',');\r\n    }\r\n    return filterValue;\r\n  }\r\n}\r\n","import {AggregationType, ApiEndpoint, TextValue} from './types';\r\n\r\n/**\r\n * The default limit.\r\n */\r\nexport const DEFAULT_LIMIT = 100;\r\n\r\n/**\r\n * The default limit for aggregation queries.\r\n */\r\nexport const DEFAULT_AGGREGATION_LIMIT = 0;\r\n\r\n/**\r\n * Supported aggregation functions.\r\n */\r\nexport const AGGREGATION_TYPES = <AggregationType[]>[\r\n  {\r\n    value: 'count',\r\n    text: 'Count',\r\n    requiresTarget: false,\r\n  },\r\n  {\r\n    value: 'sum',\r\n    text: 'Sum',\r\n    requiresTarget: true,\r\n  },\r\n];\r\n\r\n/**\r\n * Sensu API endpoints.\r\n */\r\nexport const API_ENDPOINTS = <ApiEndpoint[]>[\r\n  {\r\n    text: 'Entity API',\r\n    value: 'entity',\r\n    url: '/entities',\r\n    fieldSelectors: [\r\n      // defined by the response filter feature (see: https://docs.sensu.io/sensu-go/latest/api/#response-filtering)\r\n      'entity.name',\r\n      'entity.namespace',\r\n      'entity.deregister',\r\n      'entity.entity_class',\r\n      'entity.subscriptions',\r\n    ],\r\n  },\r\n  {\r\n    text: 'Events API',\r\n    value: 'events',\r\n    url: '/events',\r\n    fieldSelectors: [\r\n      'event.is_silenced',\r\n      'event.name',\r\n      'event.namespace',\r\n      'event.check.handlers',\r\n      'event.check.is_silenced',\r\n      'event.check.name',\r\n      'event.check.publish',\r\n      'event.check.round_robin',\r\n      'event.check.runtime_assets',\r\n      'event.check.status',\r\n      'event.check.subscriptions',\r\n      'event.entity.deregister',\r\n      'event.entity.entity_class',\r\n      'event.entity.name',\r\n      'event.entity.subscriptions',\r\n    ],\r\n  },\r\n  {\r\n    text: 'Namespaces API',\r\n    value: 'namespaces',\r\n    url: '/namespaces',\r\n    fieldSelectors: ['namespace.name'],\r\n  },\r\n];\r\n\r\n/**\r\n * Supported query types.\r\n */\r\nexport const QUERY_TYPES = <TextValue[]>[\r\n  {\r\n    value: 'field',\r\n    text: 'Field Selection',\r\n  },\r\n  {\r\n    value: 'aggregation',\r\n    text: 'Aggregation',\r\n  },\r\n];\r\n\r\n/**\r\n * Supported result data formats.\r\n */\r\nexport const FORMATS = <TextValue[]>[\r\n  {\r\n    value: 'table',\r\n    text: 'Table',\r\n  },\r\n  {\r\n    value: 'table-v',\r\n    text: 'Table (Vertical)',\r\n  },\r\n  {\r\n    value: 'series',\r\n    text: 'Time Series',\r\n  },\r\n];\r\n\r\n/**\r\n * Properties containing a timestamp and should converted (from seconds to miliseconds).\r\n */\r\nexport const TIME_PROPERTIES: string[] = [\r\n  'timestamp',\r\n  'check.executed',\r\n  'check.issued',\r\n  'check.last_ok',\r\n  'entity.last_seen',\r\n  'last_seen',\r\n];\r\n","import _ from 'lodash';\r\n\r\n/**\r\n * Returns whether the given data value matchs the filter specified by the filter value in combination with the given operator.\r\n * @param filterValue the filter value\r\n * @param operator the operator used for comparision\r\n * @param dataValue the data value to test\r\n */\r\nexport const matchs = (\r\n  filterValue: string,\r\n  operator: string,\r\n  dataValue: number | string | boolean\r\n): boolean => {\r\n  if (operator === '==') {\r\n    return filterValue == dataValue;\r\n  }\r\n  if (operator === '!=') {\r\n    return filterValue != dataValue;\r\n  }\r\n  if (operator === '=~' || operator === '!~') {\r\n    return _matchRegExp(filterValue, operator, dataValue);\r\n  }\r\n  if (operator === '<' || operator === '>') {\r\n    return _matchNumber(filterValue, operator, dataValue);\r\n  }\r\n\r\n  throw 'Unsupported operator \"' + operator + '\"';\r\n};\r\n\r\n/**\r\n * Matching using '>' and '<' operators.\r\n */\r\nconst _matchNumber = (filterValue: string, operator: string, dataValue: any) => {\r\n  const filterNumber = Number(filterValue);\r\n\r\n  if (!_.isFinite(filterNumber)) {\r\n    console.warn(\r\n      'The specified filter value (' +\r\n        filterValue +\r\n        ') is not compatible to filter on a numeric attribute.'\r\n    );\r\n    return false;\r\n  }\r\n\r\n  if (operator === '<') {\r\n    return dataValue < filterNumber;\r\n  } else {\r\n    return dataValue > filterNumber;\r\n  }\r\n};\r\n\r\n/**\r\n * Matching using regular expressions.\r\n */\r\nconst _matchRegExp = (filterValue: string, operator: string, dataValue: any) => {\r\n  const regex: RegExp = _stringToRegex(filterValue);\r\n\r\n  if (operator === '=~') {\r\n    return regex.test(dataValue);\r\n  } else {\r\n    return !regex.test(dataValue);\r\n  }\r\n};\r\n\r\n/**\r\n * Converts a string to a RegExp instance and keeps optional modifiers.\r\n * @param value the string to convert\r\n */\r\nconst _stringToRegex = (value: string) => {\r\n  const regex = value.match(/\\/(.*)\\/(\\w*)/);\r\n  if (regex) {\r\n    return new RegExp(regex[1], regex[2]);\r\n  } else {\r\n    return new RegExp(value);\r\n  }\r\n};\r\n\r\nexport default {matchs};\r\n","import _ from 'lodash';\r\nimport {DEFAULT_LIMIT, DEFAULT_AGGREGATION_LIMIT} from '../constants';\r\n\r\nimport {\r\n  QueryComponents,\r\n  GrafanaTarget,\r\n  ServerSideFilterType,\r\n  ServerSideFilter,\r\n  ClientSideFilter,\r\n} from '../types';\r\n\r\n/** RegEx matching a in-browser filter of the WHERE-clause. */\r\nconst CLIENT_FILTER_REG_EXP = '([^\\\\s:=!]+)\\\\s*(==|=~|!=|>|<|!~|=)\\\\s*(\\\\S+)';\r\n\r\n/** RegExp of a filter key or value of the server-side filter. */\r\nconst SERVER_FILTER_VALUE_REG_EXP = '\\\\[[^[]+\\\\]|\"[^\"]+\"|\\\\S+';\r\n\r\n/** RegEx matching a response filter (server-side) of the WHERE-clause. */\r\nconst SERVER_FILTER_REG_EXP =\r\n  '(fieldSelector|labelSelector):(' +\r\n  SERVER_FILTER_VALUE_REG_EXP +\r\n  ')\\\\s*(==|!=|IN|NOTIN|MATCHES)\\\\s*(' +\r\n  SERVER_FILTER_VALUE_REG_EXP +\r\n  ')';\r\n\r\n/** RegEx representing a single element of the WHERE-clause. */\r\nconst QUERY_SINGLE_FILTER_REG_EXP =\r\n  '(' + SERVER_FILTER_REG_EXP + '|' + CLIENT_FILTER_REG_EXP + ')';\r\n\r\n/** RegEx representing the whole query string. */\r\nconst QUERY_FULL_REG_EXP =\r\n  '^\\\\s*QUERY\\\\s+API\\\\s+(entity|events|namespaces)\\\\s+(IN\\\\s+NAMESPACE\\\\s+(\\\\S+)\\\\s+)?SELECT\\\\s+(\\\\S+)(\\\\s+WHERE\\\\s+(' +\r\n  QUERY_SINGLE_FILTER_REG_EXP +\r\n  '(\\\\s+AND\\\\s+' +\r\n  QUERY_SINGLE_FILTER_REG_EXP +\r\n  ')*))?(\\\\s+LIMIT\\\\s+(\\\\d+))?\\\\s*$';\r\n\r\n/**\r\n * Creates a query string based on the target definition.\r\n * @param target the data used by the query\r\n */\r\nexport function targetToQueryString(target: GrafanaTarget): string {\r\n  let query: string = 'QUERY API ' + target.apiEndpoints;\r\n\r\n  query += _namespace(target);\r\n\r\n  if (target.queryType === 'field') {\r\n    query += _queryTypeField(target);\r\n  } else if (target.queryType === 'aggregation') {\r\n    query += _queryTypeAggregation(target);\r\n  }\r\n\r\n  query += _whereClause(target);\r\n  query += _limit(target);\r\n\r\n  return query;\r\n}\r\n\r\n/**\r\n * Return the \"select\" statement based on the given target.\r\n * E.g.: SELECT field, another.field AS myField\r\n */\r\nconst _queryTypeField = (target: GrafanaTarget) => {\r\n  const fields = _(target.fieldSelectors)\r\n    .flatMap(selector => {\r\n      if (selector.alias) {\r\n        return selector.getPath() + ' AS ' + selector.alias;\r\n      } else {\r\n        return selector.getPath();\r\n      }\r\n    })\r\n    .join(', ');\r\n\r\n  return ' SELECT ' + fields;\r\n};\r\n\r\n/**\r\n * Return the \"aggregation\" statement based on the given target.\r\n * E.g.:  AGGREGATE sum ON field\r\n */\r\nconst _queryTypeAggregation = (target: GrafanaTarget) => {\r\n  let query: string = ' AGGREGATE ' + target.aggregationType;\r\n\r\n  if (target.aggregationRequiresTarget) {\r\n    query += ' ON ' + target.aggregationField;\r\n  }\r\n\r\n  return query;\r\n};\r\n\r\n/**\r\n * Return the namespace statement based on the given target.\r\n * E.g.:  IN NAMESPACE default\r\n */\r\nconst _namespace = (target: GrafanaTarget) => {\r\n  if (target.namespace === 'default') {\r\n    return '';\r\n  } else {\r\n    return ' IN NAMESPACE ' + target.namespace;\r\n  }\r\n};\r\n\r\n/**\r\n * Return the where clause based on the given target.\r\n * E.g.: WHERE field=value AND status>0\r\n */\r\nconst _whereClause = (target: GrafanaTarget) => {\r\n  const {clientSideFilters, serverSideFilters} = target;\r\n\r\n  const serverFilters = _(serverSideFilters)\r\n    .map(\r\n      filter =>\r\n        (filter.type == ServerSideFilterType.FIELD ? 'fieldSelector' : 'labelSelector') +\r\n        ':' +\r\n        filter.key +\r\n        ' ' +\r\n        filter.matcher.toUpperCase() +\r\n        ' ' +\r\n        filter.value\r\n    )\r\n    .value();\r\n\r\n  const clientFilters = _(clientSideFilters)\r\n    .map(filter => filter.key + ' ' + filter.matcher + ' ' + filter.value)\r\n    .value();\r\n\r\n  const whereClause = _([serverFilters, clientFilters])\r\n    .flatten()\r\n    .join(' AND ');\r\n\r\n  if (whereClause) {\r\n    return ' WHERE ' + whereClause;\r\n  } else {\r\n    return '';\r\n  }\r\n};\r\n\r\n/**\r\n * Return the limit statement based on the given target. If no limit is specified the default limit will be used.\r\n * E.g.: LIMIT 100\r\n */\r\nconst _limit = (target: GrafanaTarget) => {\r\n  let queryLimit: number;\r\n\r\n  if (target.limit) {\r\n    queryLimit = _.defaultTo(parseInt(target.limit), DEFAULT_LIMIT);\r\n  } else {\r\n    // Use a special default limit in aggregation queries\r\n    if (target.queryType === 'aggregation') {\r\n      queryLimit = DEFAULT_AGGREGATION_LIMIT;\r\n    } else {\r\n      queryLimit = DEFAULT_LIMIT;\r\n    }\r\n  }\r\n\r\n  if (queryLimit > 0) {\r\n    return ' LIMIT ' + queryLimit;\r\n  } else {\r\n    return '';\r\n  }\r\n};\r\n\r\nexport const extractQueryComponents = (query: string): QueryComponents | null => {\r\n  const queryRegExp = new RegExp(QUERY_FULL_REG_EXP, 'i');\r\n  const matchResult = query.match(queryRegExp);\r\n\r\n  if (!matchResult) {\r\n    return null;\r\n  }\r\n\r\n  let namespace: string;\r\n  if (matchResult[3] !== undefined) {\r\n    namespace = matchResult[3];\r\n  } else {\r\n    namespace = 'default';\r\n  }\r\n\r\n  const components: QueryComponents = {\r\n    apiKey: matchResult[1],\r\n    namespace: namespace,\r\n    selectedField: matchResult[4],\r\n    clientFilters: [],\r\n    serverFilters: [],\r\n    limit: parseInt(matchResult[25]),\r\n  };\r\n\r\n  if (matchResult[6] !== undefined) {\r\n    const filterRegExp = new RegExp(\r\n      SERVER_FILTER_REG_EXP + '|' + CLIENT_FILTER_REG_EXP,\r\n      'gi'\r\n    );\r\n\r\n    const whereClause: string = matchResult[6];\r\n\r\n    let match: RegExpExecArray | null;\r\n    while ((match = filterRegExp.exec(whereClause)) !== null) {\r\n      const isServerFilter = match[1] !== undefined;\r\n\r\n      if (isServerFilter) {\r\n        // add response filter\r\n        const filter: ServerSideFilter = {\r\n          type:\r\n            match[1] === 'fieldSelector'\r\n              ? ServerSideFilterType.FIELD\r\n              : ServerSideFilterType.LABEL,\r\n          key: match[2],\r\n          matcher: match[3],\r\n          value: match[4],\r\n        };\r\n\r\n        components.serverFilters.push(filter);\r\n      } else {\r\n        // add in-browser filter\r\n        const filter: ClientSideFilter = {\r\n          key: match[5],\r\n          matcher: match[6] === '=' ? '==' : match[6],\r\n          value: match[7],\r\n        };\r\n\r\n        components.clientFilters.push(filter);\r\n      }\r\n    }\r\n  }\r\n\r\n  return components;\r\n};\r\n\r\nexport default {targetToQueryString, extractQueryComponents};\r\n","import {DataPoint, GrafanaTable} from '../types';\r\nimport {TIME_PROPERTIES} from '../constants';\r\nimport _ from 'lodash';\r\nimport moment from 'moment';\r\n\r\n/**\r\n * Transforms the given data into a table representation.\r\n */\r\nconst transform = (dataMatrix: DataPoint[][], vertical: boolean): GrafanaTable => {\r\n  const columns = _extractColumns(dataMatrix);\r\n\r\n  // create column index mapping\r\n  const columnIndexMap = {};\r\n  _.each(columns, (column, index) => (columnIndexMap[column.text] = index));\r\n\r\n  // generate data rows\r\n  const rows: any[][] = _.map(dataMatrix, dataRow => {\r\n    const row = _.times(columns.length, _.constant(null));\r\n\r\n    _(dataRow)\r\n      .map(({name, value}) => {\r\n        if (_.isArray(value)) {\r\n          return _.map(value, (element, index) => [name + '[' + index + ']', element]);\r\n        } else {\r\n          return [[name, value]];\r\n        }\r\n      })\r\n      .flatten()\r\n      .map(data => {\r\n        if (_.isPlainObject(data[1]) || _.isArray(data[1])) {\r\n          data[1] = JSON.stringify(data[1]);\r\n        }\r\n        return data;\r\n      })\r\n      .each(([columnName, value]) => {\r\n        row[columnIndexMap[columnName]] = value;\r\n      });\r\n\r\n    return row;\r\n  });\r\n\r\n  if (vertical) {\r\n    return _asVerticalTable(columns, rows);\r\n  }\r\n\r\n  // create grafana result object\r\n  return <GrafanaTable>{\r\n    columns,\r\n    rows,\r\n    type: 'table',\r\n  };\r\n};\r\n\r\nconst _asVerticalTable = (dataColumns, dataRows: any[][]): GrafanaTable => {\r\n  // fixed table headers\r\n  const columns = [\r\n    {\r\n      text: 'Attribute',\r\n    },\r\n    {\r\n      text: 'Value',\r\n    },\r\n  ];\r\n\r\n  const rows = _(dataRows)\r\n    .flatten()\r\n    .map((value, idx) => [dataColumns[idx].text, value])\r\n    .value();\r\n\r\n  // this is done because users cannot define a time formatting based on rows\r\n  _convertTimestamps(rows);\r\n\r\n  return <GrafanaTable>{\r\n    columns,\r\n    rows,\r\n    type: 'table',\r\n  };\r\n};\r\n\r\nconst _convertTimestamps = (rows: any[][]) => {\r\n  _.each(rows, row => {\r\n    const attribute = row[0];\r\n    const value = row[1];\r\n\r\n    for (let index = 0; index < TIME_PROPERTIES.length; index++) {\r\n      if (attribute === TIME_PROPERTIES[index]) {\r\n        const time = _.defaultTo(value, -1);\r\n        if (time > 0) {\r\n          row[1] = moment(time).format('YYYY-MM-DD HH:mm:ss');\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Returns an array of columns which exist in the given data matrix. Each data point attribute will be\r\n * represents by a column.\r\n *\r\n * @param dataMatrix the data basis\r\n */\r\nconst _extractColumns = (dataMatrix: DataPoint[][]) => {\r\n  const isArrayMarker = {};\r\n\r\n  // extract existing columns\r\n  return _(dataMatrix)\r\n    .flatten()\r\n    .map(({name, value}) => {\r\n      if (_.isArray(value)) {\r\n        isArrayMarker[name] = true;\r\n        return _.times(value.length, index => name + '[' + index + ']');\r\n      } else {\r\n        if (_.isNil(value) && _.get(isArrayMarker, name, false)) {\r\n          return [];\r\n        }\r\n        return [name];\r\n      }\r\n    })\r\n    .flatten()\r\n    .uniq()\r\n    .map(name => {\r\n      return {\r\n        text: name,\r\n      };\r\n    })\r\n    .value();\r\n};\r\n\r\nexport default transform;\r\n","import {DataPoint, GrafanaTable, GrafanaTimeSeries} from '../types';\r\nimport table_transform from './table_transformer';\r\nimport timeseries_transform from './timeseries_transformer';\r\n\r\nexport default {\r\n  toTable: (dataMatrix: DataPoint[][], vertical: boolean): GrafanaTable => {\r\n    return table_transform(dataMatrix, vertical);\r\n  },\r\n  toTimeSeries: (dataMatrix: DataPoint[][]): GrafanaTimeSeries[] => {\r\n    return timeseries_transform(dataMatrix);\r\n  },\r\n};\r\n","import {DataPoint, GrafanaTimeSeries} from '../types';\r\nimport _ from 'lodash';\r\n\r\n/**\r\n * Transforms the given data into a time series representation.\r\n */\r\nconst transform = (dataMatrix: DataPoint[][]): GrafanaTimeSeries[] => {\r\n  const now: number = Date.now();\r\n\r\n  // maps the data to a series - skips all values which are not finite\r\n  // - name => series name\r\n  // - value => value\r\n  return _(dataMatrix)\r\n    .flatten()\r\n    .filter(data => _.isFinite(data.value))\r\n    .map(data => {\r\n      return <GrafanaTimeSeries>{\r\n        target: data.name,\r\n        datapoints: [[data.value, now]],\r\n      };\r\n    })\r\n    .value();\r\n};\r\n\r\nexport default transform;\r\n","import _ from 'lodash';\r\nimport {ClientSideFilter, GrafanaTarget} from '../types';\r\n\r\n/** The latest configuration version. */\r\nconst LATEST_VERSION = 2;\r\n\r\n/** Migrates the passed configuration target to the latest version. The passed object will be mutated. */\r\nconst migrate = (target: GrafanaTarget): GrafanaTarget => {\r\n  const {version} = target;\r\n\r\n  if (version === undefined) {\r\n    init(target);\r\n  }\r\n  if (version === 1) {\r\n    toVersion2(target);\r\n  }\r\n\r\n  return target;\r\n};\r\n\r\n/** Initializes the configuration target. */\r\nconst init = (target: GrafanaTarget) => {\r\n  target.version = LATEST_VERSION;\r\n  target.clientSideFilters = [];\r\n  target.serverSideFilters = [];\r\n};\r\n\r\n/** Migrates the passed configuration target from version 1 to version 2. */\r\nconst toVersion2 = (target: GrafanaTarget) => {\r\n  console.log('Migrating data source configuration to version 2.');\r\n\r\n  const {filterSegments} = target;\r\n\r\n  const filters = _(filterSegments)\r\n    .filter(segments => segments.length === 3)\r\n    .filter(segments => !_.get(segments[2], 'fake', false))\r\n    .map(segments => {\r\n      const matcher = segments[1].value === '=' ? '==' : segments[1].value;\r\n\r\n      return <ClientSideFilter>{\r\n        key: segments[0].value,\r\n        matcher,\r\n        value: segments[2].value,\r\n      };\r\n    })\r\n    .value();\r\n\r\n  delete target.filterSegments;\r\n\r\n  target.clientSideFilters = filters;\r\n  target.serverSideFilters = [];\r\n\r\n  target.version = 2;\r\n};\r\n\r\nexport default {\r\n  migrate,\r\n};\r\n","import _ from 'lodash';\n\nimport sensu from './sensu/sensu';\nimport {\n  API_ENDPOINTS,\n  DEFAULT_LIMIT,\n  DEFAULT_AGGREGATION_LIMIT,\n  TIME_PROPERTIES,\n} from './constants';\nimport FieldSelector from './FieldSelector';\nimport FilterUtils from './utils/datasource_filter_util';\nimport QueryUtils from './utils/query_util';\nimport transformer from './transformer';\nimport ConfigMigration from './utils/config_migration_util';\nimport AggregationUtils from './utils/data_aggregation_util';\n\nimport {\n  PreparedTarget,\n  ColumnMapping,\n  DataPoint,\n  ClientSideFilter,\n  QueryComponents,\n  InstanceSettings,\n  QueryOptions,\n  GrafanaTarget,\n} from './types';\n\nexport default class SensuDatasource {\n  url: string;\n\n  /** @ngInject */\n  constructor(\n    public instanceSettings: InstanceSettings,\n    public backendSrv,\n    private templateSrv\n  ) {\n    this.url = instanceSettings.url.trim();\n  }\n\n  /**\n   * Preprocces the query targets like resolving template variables.\n   */\n  prepareQuery = (target: GrafanaTarget, queryOptions) => {\n    // resolve API url\n    const apiUrl = this._getApiUrl(target);\n    // resolve filters\n    const clientFilters = _.cloneDeep(target.clientSideFilters);\n    const serverFilters = _.cloneDeep(target.serverSideFilters);\n\n    const preparedTarget: PreparedTarget = <PreparedTarget>{\n      apiUrl,\n      clientFilters,\n      serverFilters,\n      target: _.cloneDeep(target), //ensure modifications are not globally propagated\n    };\n\n    this._resolveTemplateVariables(preparedTarget, queryOptions);\n\n    return preparedTarget;\n  };\n\n  /**\n   * Resolves template variables in the given prepared target.\n   */\n  _resolveTemplateVariables = (preparedTarget: PreparedTarget, queryOptions) => {\n    const {target, clientFilters, serverFilters} = preparedTarget;\n\n    // resolve variables in namespaces\n    const namespaces: string[] = this.templateSrv\n      .replace(target.namespace, queryOptions.scopedVars, 'pipe')\n      .split('|');\n\n    target.namespaces = namespaces;\n\n    // resolve variables in filters\n    [clientFilters, serverFilters].forEach(filters =>\n      filters.forEach(filter => {\n        filter.key = this.templateSrv.replace(filter.key, queryOptions.scopedVars, 'csv');\n        filter.value = this.templateSrv.replace(\n          filter.value,\n          queryOptions.scopedVars,\n          'regex'\n        );\n      })\n    );\n  };\n\n  /**\n   * Returns the url of the API used by the given target.\n   */\n  _getApiUrl = (target: GrafanaTarget) => {\n    const apiEndpoint: any = _.find(API_ENDPOINTS, {value: target.apiEndpoints});\n    if (apiEndpoint) {\n      return apiEndpoint.url;\n    } else {\n      return API_ENDPOINTS[0].url;\n    }\n  };\n\n  /**\n   * Executes a query.\n   */\n  query(queryOptions) {\n    const queryTargets = _(queryOptions.targets)\n      .filter(target => !target.hide)\n      .map(ConfigMigration.migrate)\n      .map(target => this.prepareQuery(target, queryOptions))\n      .value();\n\n    // empty result in case there is no query defined\n    if (queryTargets.length === 0) {\n      return Promise.resolve({data: []});\n    }\n\n    const queries = queryTargets.map(prepTarget => {\n      const {\n        apiUrl,\n        clientFilters,\n        serverFilters,\n        target: {queryType, fieldSelectors, namespaces, limit},\n      } = prepTarget;\n\n      // verify and set correct limit\n      let parsedLimit: number = _.defaultTo(parseInt(limit || ''), -1);\n      if (parsedLimit < 0) {\n        if (queryType === 'aggregation') {\n          parsedLimit = DEFAULT_AGGREGATION_LIMIT;\n        } else {\n          parsedLimit = DEFAULT_LIMIT;\n        }\n      }\n\n      const queryOptions: QueryOptions = {\n        method: 'GET',\n        url: apiUrl,\n        namespaces,\n        limit: parsedLimit,\n        responseFilters: serverFilters,\n      };\n\n      return sensu\n        .query(this, queryOptions)\n        .then(this._timeCorrection)\n        .then(data => this._filterData(data, clientFilters))\n        .then(data => {\n          if (queryType === 'field') {\n            return this._queryFieldSelection(data, fieldSelectors);\n          } else if (queryType === 'aggregation') {\n            return this._queryGroupAndAggregate(data, prepTarget);\n          } else {\n            return [];\n          }\n        });\n    });\n\n    return Promise.all(queries).then((queryResults: any) => {\n      if (queryOptions.resultAsPlainArray) {\n        // return only values - e.g. for template variables\n        const result = _(queryResults)\n          .map(result => transformer.toTable(result, false))\n          .map(result => result.rows)\n          .flatten()\n          .flatten()\n          .filter()\n          .map(value => {\n            return {text: value};\n          })\n          .value();\n\n        return result;\n      } else {\n        const resultDataList: any[] = _.flatMap(queryResults, (queryResult, index) => {\n          const {target: {format}} = queryTargets[index];\n\n          if (format === 'series') {\n            // return time series format\n            return transformer.toTimeSeries(queryResult);\n          } else {\n            const isVertical = format === 'table-v';\n            // return table format\n            return transformer.toTable(queryResult, isVertical);\n          }\n        });\n\n        return {\n          data: resultDataList,\n        };\n      }\n    });\n  }\n\n  /**\n   * Converting the timestamps from seconds to miliseconds because Sensu's timestamp\n   * resolution is in seconds but Grafana uses miliseconds.\n   */\n  _timeCorrection = (data: any) => {\n    _.each(data, dataElement => {\n      // iterate over all time properties\n      _.each(TIME_PROPERTIES, property => {\n        // fetch the properties value\n        const time = _.get(dataElement, property, -1);\n        // in case a time is set, we multiply them by 1000 to get miliseconds.\n        // in case the time is 0, we'll remove it, otherwise Grafana will display the epoch's starting times\n        if (time > 0) {\n          _.set(dataElement, property, time * 1000);\n        } else {\n          _.unset(dataElement, property);\n        }\n      });\n    });\n    return data;\n  };\n\n  /**\n   * This function will group the given data (if specified in the PreparedTarget) and aggregate it accordingly.\n   *\n   * @param data the data to group and aggregate\n   * @param prepTarget the settings for the grouping and aggregation\n   */\n  _queryGroupAndAggregate = (data: any[], prepTarget: PreparedTarget) => {\n    const {\n      target: {\n        aggregationAlias: alias,\n        aggregationType: type,\n        format,\n        groupBy: groupAttribute,\n      },\n    } = prepTarget;\n    // the name of the result value (the metric name if timeseries format is used, otherwise the column header)\n    const name = alias ? alias : type || 'value';\n\n    if (!groupAttribute) {\n      // just aggregate without grouping\n      const aggregationResult = this._queryAggregation(data, name, prepTarget);\n      return [aggregationResult];\n    } else {\n      // first group the data..\n      const groups = _.groupBy(data, groupAttribute);\n\n      // ..then aggregate the individual groups\n      const groupResult = _(groups)\n        .map((dataGroup, groupKey) =>\n          this._queryAggregation(dataGroup, groupKey, prepTarget)\n        )\n        .value();\n\n      if ((format === 'table' || format === 'table-v') && groupResult) {\n        const {groupAlias} = prepTarget.target;\n        // we transform the groups into multiple columns in case the table format is used\n        return this._mergeTableAggregation(\n          groupResult,\n          groupAlias || groupAttribute,\n          name\n        );\n      } else {\n        return groupResult;\n      }\n    }\n  };\n\n  /**\n   * We merge the seperate aggregation result into a single one, thus we get a nicer visualization\n   * in the table panel, where the group-attribute and value have their own column.\n   */\n  _mergeTableAggregation = (\n    groupData: (DataPoint[] | null)[],\n    groupByAttribute: string,\n    alias: string\n  ) => {\n    return _(groupData)\n      .map(group => {\n        if (!group || group.length == 0) {\n          return null;\n        }\n        const point: DataPoint = group[0];\n        return [\n          {\n            name: groupByAttribute,\n            value: point.name,\n          },\n          {\n            name: alias,\n            value: point.value,\n          },\n        ];\n      })\n      .filter() // null values\n      .value();\n  };\n\n  /**\n   * Process the data if the query type is 'aggregation'.\n   */\n  _queryAggregation = (data: any[], name: string, prepTarget: PreparedTarget) => {\n    const {aggregationType: type} = prepTarget.target;\n\n    if (type === 'count') {\n      return AggregationUtils.count(data, name);\n    } else if (type === 'sum') {\n      const {aggregationField} = prepTarget.target;\n      return AggregationUtils.sum(data, name, aggregationField);\n    } else {\n      throw new Error('The aggreation type \"' + type + '\" is not supported.');\n    }\n  };\n\n  /**\n   * Process the data if the query type is 'field'.\n   */\n  _queryFieldSelection = (data: any, fieldSelectors: FieldSelector[]) => {\n    const columnMappings: ColumnMapping[] = this._extractColumnMappings(\n      data,\n      fieldSelectors\n    );\n\n    const resultData = _.map(data, dataElement => {\n      // extract selected data\n      return _.map(columnMappings, mapping => {\n        const value: any = _.get(dataElement, mapping.path);\n\n        return <DataPoint>{\n          name: mapping.alias,\n          value: value,\n        };\n      });\n    });\n\n    return resultData;\n  };\n\n  /**\n   * Creates a column mapping - which object attribute/path is related to which column.\n   */\n  _extractColumnMappings = (data: any, fieldSelectors: FieldSelector[]) => {\n    const result: ColumnMapping[] = _.flatMap(fieldSelectors, selector => {\n      const paths = _(data)\n        .map(dataElement => this.resolvePaths(selector, dataElement))\n        .flatMap()\n        .uniq()\n        .value();\n\n      if (selector.alias) {\n        if (paths.length > 1) {\n          // use the alias in combination with an index as column name\n          return _.map(paths, (path, index) => {\n            return <ColumnMapping>{\n              path: path,\n              alias: selector.alias + '.' + index,\n            };\n          });\n        } else {\n          // use the alias instead the path as column name\n          return _.map(paths, path => {\n            return <ColumnMapping>{\n              path: path,\n              alias: selector.alias,\n            };\n          });\n        }\n      } else {\n        // use the path itself as column name\n        return _.map(paths, path => {\n          return <ColumnMapping>{\n            path: path,\n            alias: path,\n          };\n        });\n      }\n    });\n\n    return result;\n  };\n\n  /**\n   * Returns a filtered representation of the given data.\n   */\n  _filterData = (data: any, filters: ClientSideFilter[]) => {\n    return _.filter(data, dataElement =>\n      _.every(filters, filter => this._matches(dataElement, filter))\n    );\n  };\n\n  /**\n   * Returns whether the given element matches the given filter.\n   */\n  _matches = (element: any, filter: ClientSideFilter) => {\n    const filterKey: string = filter.key;\n    const matcher: string = filter.matcher;\n    const filterValue: string = filter.value;\n\n    const elementValue: any = _.get(element, filterKey);\n\n    return FilterUtils.matchs(filterValue, matcher, elementValue);\n  };\n\n  /**\n   * Resolves all existing paths of the specified selector based on the given data.\n   * Example: if the selector is '*' all possible attibutes (including nested) will be returned.\n   */\n  resolvePaths = (selector: any, data: any) => {\n    let selection: any = data;\n    let lastSelector = '';\n    let basePath = '';\n\n    for (let i = 0; i < selector.fieldSegments.length; i++) {\n      const segment: any = selector.fieldSegments[i];\n      lastSelector = segment.value;\n\n      if (lastSelector !== '*') {\n        if (basePath === '') {\n          basePath = lastSelector;\n        } else {\n          basePath = basePath + '.' + lastSelector;\n        }\n        selection = _.get(selection, lastSelector);\n      }\n    }\n\n    if (lastSelector === '*') {\n      const paths = this._deepResolve(selection);\n      if (basePath === '') {\n        return paths;\n      } else {\n        return _.map(paths, path => basePath + '.' + path);\n      }\n    } else {\n      return [basePath];\n    }\n  };\n\n  _deepResolve = data => {\n    const keys: string[] = Object.keys(data);\n\n    return _.flatMap(keys, key => {\n      if (_.isPlainObject(data[key])) {\n        return _.map(this._deepResolve(data[key]), nestedKeys => {\n          return key + '.' + nestedKeys;\n        });\n      } else {\n        return key;\n      }\n    });\n  };\n\n  /**\n   * Executes a query based on the given query command which is a string representation of it.\n   */\n  metricFindQuery(query: string) {\n    return this._query(query);\n  }\n\n  /**\n   * Executes the given query command.\n   */\n  _query = (query: string) => {\n    const queryComponents = QueryUtils.extractQueryComponents(query);\n\n    if (queryComponents === null) {\n      return Promise.resolve([]);\n    }\n    const options: any = this._transformQueryComponentsToQueryOptions(queryComponents);\n    options.resultAsPlainArray = true;\n\n    return this.query(options);\n  };\n\n  /**\n   * Transforms the given query components into an options object which can be used by the `query(..)` function.\n   */\n  _transformQueryComponentsToQueryOptions = (queryComponents: QueryComponents) => {\n    const {\n      apiKey,\n      selectedField,\n      clientFilters,\n      serverFilters,\n      namespace,\n      limit,\n    } = queryComponents;\n\n    const options = {\n      targets: [\n        <GrafanaTarget>{\n          apiEndpoints: apiKey,\n          queryType: 'field',\n          namespace: namespace,\n          limit: _.isNaN(limit) ? null : new String(limit),\n          fieldSelectors: [\n            <FieldSelector>{\n              fieldSegments: [\n                {\n                  value: selectedField,\n                },\n              ],\n            },\n          ],\n          format: 'table',\n          clientSideFilters: clientFilters,\n          serverSideFilters: serverFilters,\n          version: 2,\n        },\n      ],\n    };\n\n    return options;\n  };\n\n  /**\n   * Used by the config UI to test a datasource.\n   */\n  testDatasource() {\n    const useApiKey = _.get(this.instanceSettings, 'jsonData.useApiKey', false);\n\n    // the /auth/test endpoint is only available for testing basic auth credentials\n    const testUrl = useApiKey ? '/api/core/v2/namespaces' : '/auth/test';\n\n    return sensu\n      ._request(this, 'GET', testUrl)\n      .then(() => {\n        return {\n          status: 'success',\n          message: 'Successfully connected against the Sensu Go API',\n        };\n      })\n      .catch(error => {\n        if (useApiKey && error.data === 'access_error') {\n          return {\n            status: 'error',\n            message: 'API Key Invalid: Could not logged in using API key',\n          };\n        }\n        return {status: 'error', message: error.message};\n      });\n  }\n}\n","import _ from 'lodash';\r\nimport {DataPoint} from '../types';\r\n\r\n/**\r\n * Does a count aggregation. The number of elements in the given data is returned.\r\n *\r\n * @param data the data to aggregate\r\n * @param name  the name of the resulting value\r\n */\r\nconst count = (data: any[], name: string): DataPoint[] => {\r\n  return <DataPoint[]>[\r\n    {\r\n      name,\r\n      value: data.length,\r\n    },\r\n  ];\r\n};\r\n\r\n/**\r\n * Does a sum aggregation. The sum of the specified attribute of all elements in the given data is calculated.\r\n *\r\n * @param data  the data to aggregate\r\n * @param name the name of the resulting value\r\n * @param targetField  the field which should be summed up\r\n */\r\nconst sum = (\r\n  data: any[],\r\n  name: string,\r\n  targetField: string | undefined\r\n): DataPoint[] | null => {\r\n  if (!targetField) {\r\n    return [];\r\n  }\r\n\r\n  let sum: number | null = _.sumBy(data, targetField);\r\n\r\n  if (!_.isFinite(sum)) {\r\n    sum = null;\r\n  }\r\n\r\n  return <DataPoint[]>[\r\n    {\r\n      name,\r\n      value: sum,\r\n    },\r\n  ];\r\n};\r\n\r\nexport default {count, sum};\r\n","import _ from 'lodash';\r\nimport {SensuQueryCtrl} from './query_ctrl';\r\n\r\n/**\r\n * Helper class for building field selectors.\r\n * This class should be refactored => no segments should be in `target` but directly in the query controller.\r\n */\r\nexport default class FieldSelector {\r\n  fieldSegments: any[];\r\n\r\n  fieldType: string;\r\n\r\n  attributePath: string;\r\n\r\n  alias: string;\r\n\r\n  /**\r\n   * Restores the segments based on the given parameters.\r\n   */\r\n  static restore = (ctrl: SensuQueryCtrl, segments: FieldSelector): FieldSelector => {\r\n    const path = _(segments.fieldSegments)\r\n      .map(segment => segment.value)\r\n      .join('.');\r\n\r\n    const selector: FieldSelector = new FieldSelector(ctrl, path);\r\n\r\n    selector.alias = segments.alias;\r\n\r\n    return selector;\r\n  };\r\n\r\n  constructor(ctrl: SensuQueryCtrl, initPath: string) {\r\n    this.fieldSegments = _.map(initPath.split('.'), path =>\r\n      ctrl.uiSegmentSrv.newKey(path)\r\n    );\r\n    this.refresh(ctrl);\r\n  }\r\n\r\n  /**\r\n   * Refreshes the selectors UI elements - if a segment changes its value.\r\n   */\r\n  refresh = (ctrl: SensuQueryCtrl): void => {\r\n    if (!ctrl.dataPreview || ctrl.dataPreview.length <= 0) {\r\n      return;\r\n    }\r\n    let selection = ctrl.dataPreview[0];\r\n\r\n    for (let i = 0; i < this.fieldSegments.length; i++) {\r\n      const segment: any = this.fieldSegments[i];\r\n      const value: string = segment.value;\r\n\r\n      if (selection) {\r\n        selection = _.get(selection, value);\r\n      }\r\n\r\n      if (value === '*') {\r\n        this.fieldSegments = this.fieldSegments.slice(0, i + 1);\r\n      }\r\n    }\r\n\r\n    if (selection === undefined) {\r\n      this.fieldType = 'undefined';\r\n    } else if (_.isPlainObject(selection)) {\r\n      this.fieldSegments.push(ctrl.uiSegmentSrv.newKey('*'));\r\n      this.fieldType = 'object';\r\n    } else if (_.isArray(selection)) {\r\n      this.fieldType = 'array';\r\n    } else if (typeof selection === 'number') {\r\n      this.fieldType = 'number';\r\n    } else {\r\n      this.fieldType = 'string';\r\n    }\r\n\r\n    this.attributePath = this.getPath();\r\n  };\r\n\r\n  /**\r\n   * Returns the current attribute path of this selector.\r\n   */\r\n  getPath = (): string => {\r\n    return _(this.fieldSegments)\r\n      .map(segment => segment.value)\r\n      .join('.');\r\n  };\r\n}\r\n","import appEvents from 'grafana/app/core/app_events';\nimport {QueryCtrl} from 'grafana/app/plugins/sdk';\nimport _ from 'lodash';\n\nimport {\n  ApiEndpoint,\n  AggregationType,\n  TextValue,\n  GrafanaTarget,\n  ClientSideFilter,\n  ServerSideFilter,\n  ServerSideFilterType,\n} from './types';\n\nimport FieldSelector from './FieldSelector';\nimport {AGGREGATION_TYPES, API_ENDPOINTS, QUERY_TYPES, FORMATS} from './constants';\nimport {targetToQueryString} from './utils/query_util';\nimport Sensu from './sensu/sensu';\nimport ConfigMigration from './utils/config_migration_util';\n\nexport class SensuQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  // Will be stored by Grafana\n  target: GrafanaTarget;\n\n  // Constants\n  readonly aggregationTypes: AggregationType[] = AGGREGATION_TYPES;\n  readonly queryTypes: TextValue[] = QUERY_TYPES;\n  readonly formats: TextValue[] = FORMATS;\n\n  segmentAggregationTarget: any;\n  dataPreview: any = {};\n  dataPreviewBuffer: any[] = [];\n\n  apiEndpoints: ApiEndpoint[] = API_ENDPOINTS; // used in the partial\n  addFieldSegment: any;\n  namespaceSegment: any;\n  groupBySegment: any;\n\n  clientFilterSegments: any[] = [];\n  serverFilterSegments: any[] = [];\n\n  /** @ngInject **/\n  constructor($scope, $injector, private $q, public uiSegmentSrv, private templateSrv) {\n    super($scope, $injector);\n\n    // Migrate existing configurations to the latest model version\n    ConfigMigration.migrate(this.target);\n\n    const {clientSideFilters, serverSideFilters} = <GrafanaTarget>this.target;\n\n    // restore client filter segments\n    _(clientSideFilters)\n      .map(this._createClientFilterSegments)\n      .each(segmentArray => this.clientFilterSegments.push(segmentArray));\n\n    this.clientFilterSegments.push([this.uiSegmentSrv.newPlusButton()]);\n\n    //restore server filter segments\n    _(serverSideFilters)\n      .map(this._createServerFilterSegments)\n      .each(segmentArray => this.serverFilterSegments.push(segmentArray));\n\n    this.serverFilterSegments.push([this.uiSegmentSrv.newPlusButton()]);\n\n    // create field selectors\n    if (this.target.fieldSelectors === undefined) {\n      this.target.fieldSelectors = [new FieldSelector(this, '*')];\n    } else {\n      this.target.fieldSelectors = _.map(this.target.fieldSelectors, selector =>\n        FieldSelector.restore(this, selector)\n      );\n    }\n\n    if (this.target.apiEndpoints === undefined) {\n      this.target.apiEndpoints = API_ENDPOINTS[0].value;\n    }\n\n    if (this.target.queryType === undefined) {\n      this.target.queryType = this.queryTypes[0].value;\n    }\n\n    if (this.target.format === undefined) {\n      this.target.format = this.formats[0].value;\n    }\n\n    this.addFieldSegment = this.uiSegmentSrv.newPlusButton();\n\n    if (this.target.aggregation !== undefined) {\n      delete this.target.aggregation;\n    }\n\n    if (this.target.aggregationType === undefined) {\n      this.target.aggregationType = AGGREGATION_TYPES[0].value;\n    }\n\n    if (this.target.aggregationRequiresTarget === undefined) {\n      this.target.aggregationRequiresTarget = AGGREGATION_TYPES[0].requiresTarget;\n    }\n\n    if (this.target.aggregationField === undefined) {\n      this.segmentAggregationTarget = this.uiSegmentSrv.newFake(\n        'select target attribute',\n        'value',\n        'query-segment-value'\n      );\n    } else {\n      this.segmentAggregationTarget = this.uiSegmentSrv.newSegment({\n        value: this.target.aggregationField,\n      });\n    }\n\n    if (this.target.groupBy === undefined) {\n      this.groupBySegment = this.uiSegmentSrv.newPlusButton();\n    } else {\n      this.groupBySegment = this.uiSegmentSrv.newSegment({\n        value: this.target.groupBy,\n      });\n    }\n\n    if (this.target.namespace === undefined) {\n      this.target.namespace = 'default';\n    }\n\n    this.namespaceSegment = this.uiSegmentSrv.newSegment({value: this.target.namespace});\n\n    appEvents.on('ds-request-response', this.onResponseReceived, $scope);\n    this.panelCtrl.events.on('refresh', this.onRefresh, $scope);\n    this.panelCtrl.events.on('data-received', this.onDataReceived, $scope);\n\n    this.panelCtrl.refresh();\n  }\n\n  /**\n   * Creates an array containg segments which represent a in-browser filter. The first segment represents the filter-key,\n   * the second the operator and the third the filter-value.\n   */\n  _createClientFilterSegments = (filter: ClientSideFilter) => {\n    const segmentArray = [\n      this.uiSegmentSrv.newKey(filter.key),\n      this.uiSegmentSrv.newOperator(filter.matcher),\n      this.uiSegmentSrv.newKeyValue(filter.value),\n    ];\n\n    return segmentArray;\n  };\n\n  /**\n   * Creates an array containg segments which represent a response filter (sever-side). The first segment represents the type\n   * of the filer (labelSelector or fieldSelector), the second the filter-key, the third the operator and the fourth the filter-value.\n   */\n  _createServerFilterSegments = (filter: ServerSideFilter) => {\n    const type =\n      filter.type === ServerSideFilterType.FIELD ? 'fieldSelector' : 'labelSelector';\n\n    const segmentArray = [\n      this.uiSegmentSrv.newCondition(type),\n      this.uiSegmentSrv.newKey(filter.key),\n      this.uiSegmentSrv.newOperator(filter.matcher),\n      this.uiSegmentSrv.newKeyValue(filter.value),\n    ];\n\n    return segmentArray;\n  };\n\n  /**\n   * Returns the currently selected aggregation type.\n   */\n  getCurrentAggregationType = () => {\n    return <AggregationType>_.find(AGGREGATION_TYPES, {\n      value: this.target.aggregationType,\n    });\n  };\n\n  /**\n   * Called if the aggregation field changes.\n   */\n  onAggregationFieldChange = () => {\n    this.target.aggregationField = this.segmentAggregationTarget.value;\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Called if the aggregation type changes.\n   */\n  onAggregationTypeChange = () => {\n    this.target.aggregationRequiresTarget = this.getCurrentAggregationType().requiresTarget;\n    this._resetAggregation();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Resets the aggregation options.\n   */\n  _resetAggregation = () => {\n    delete this.target.aggregationAlias;\n    delete this.target.aggregationField;\n\n    this.removeGroupBy();\n\n    this.segmentAggregationTarget = this.uiSegmentSrv.newFake(\n      'select target attribute',\n      'value',\n      'query-segment-value'\n    );\n  };\n\n  /**\n   * Returns selectable options (all existing keys) for the aggregation field segment.\n   */\n  getTargetOptions = () => {\n    const options: string[] = this.getAllDeepKeys();\n    const segments: any[] = _.map(options, option =>\n      this.uiSegmentSrv.newSegment({value: option})\n    );\n\n    return this.$q.when(segments);\n  };\n\n  /**\n   * Returns selectable options (all existing keys) for the group-by segment.\n   */\n  getGroupByOptions = () => {\n    const options: string[] = this.getAllDeepKeys();\n    const segments: any[] = _.map(options, option =>\n      this.uiSegmentSrv.newSegment({value: option})\n    );\n\n    return this.$q.when(segments);\n  };\n\n  /**\n   * Called when the user changes the groupBy attribute.\n   */\n  onGroupByChange = () => {\n    this.target.groupBy = this.groupBySegment.value;\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Removes the groupBy attribute.\n   */\n  removeGroupBy = () => {\n    this.groupBySegment = this.uiSegmentSrv.newPlusButton();\n    delete this.target.groupBy;\n    delete this.target.groupAlias;\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Returns selectable options for the namespace segment.\n   */\n  getNamespaceOptions = () => {\n    return Sensu.query(this.datasource, {\n      method: 'GET',\n      url: '/namespaces',\n      namespaces: [],\n      limit: 0,\n      responseFilters: [],\n    })\n      .then(result => {\n        // get existing namespaces based on query result\n        const namespaces = _.map(result, namespace => namespace.name);\n\n        // add all option\n        namespaces.unshift('*');\n\n        // add template variables\n        _.each(this.templateSrv.variables, variable =>\n          namespaces.unshift('$' + variable.name)\n        );\n\n        return _.map(namespaces, option => this.uiSegmentSrv.newSegment({value: option}));\n      })\n      .catch(() => {\n        return [];\n      });\n  };\n\n  /**\n   * Called of the namespace is changing.\n   */\n  onNamespaceChange = () => {\n    this.target.namespace = this.namespaceSegment.value;\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Resets the field and filter segments.\n   */\n  _reset = () => {\n    this.target.fieldSelectors = [new FieldSelector(this, '*')];\n    this.clientFilterSegments = [[this.uiSegmentSrv.newPlusButton()]];\n    this.serverFilterSegments = [[this.uiSegmentSrv.newPlusButton()]];\n    this._updateFilterTarget();\n  };\n\n  /**\n   * Called when the api is changing.\n   */\n  onApiChange = () => {\n    this._reset();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Called when the query type is changing.\n   */\n  onQueryTypeChange = () => {\n    this._resetAggregation();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Removes the filter at the given index.\n   */\n  removeFilter = (index: number, isServerFilter: boolean) => {\n    const targetArray = isServerFilter\n      ? this.serverFilterSegments\n      : this.clientFilterSegments;\n    targetArray.splice(index, 1);\n    this._updateFilterTarget();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Called when a filter is changing.\n   */\n  onFilterSegmentUpdate = (segment, parentIndex, index) => {\n    if (segment.type === 'plus-button') {\n      this._addClientFilterSegment(segment);\n      return;\n    }\n\n    if (index == 2) {\n      const segmentValue = segment.value;\n      if (/\\/.*\\/\\w*/.test(segmentValue)) {\n        this.clientFilterSegments[parentIndex][1] = this.uiSegmentSrv.newOperator('=~');\n      }\n    }\n\n    this._updateFilterTarget();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Adds a new in-browser filter.\n   */\n  _addClientFilterSegment = (sourceSegment: any) => {\n    const segmentArray: any[] = [\n      this.uiSegmentSrv.newKey(sourceSegment.value),\n      this.uiSegmentSrv.newOperator('=='),\n      this.uiSegmentSrv.newFake('select filter value', 'value', 'query-segment-value'),\n    ];\n\n    this.clientFilterSegments.pop();\n    this.clientFilterSegments.push(segmentArray);\n    this.clientFilterSegments.push([this.uiSegmentSrv.newPlusButton()]);\n  };\n\n  /**\n   * Adds a new response filter.\n   */\n  _addServerFilterSegment = (sourceSegment: any) => {\n    const segmentArray: any[] = [\n      this.uiSegmentSrv.newCondition(sourceSegment.value),\n      this.uiSegmentSrv.newFake('select filter key', 'value', 'query-segment-value'),\n      this.uiSegmentSrv.newOperator('=='),\n      this.uiSegmentSrv.newFake('select filter value', 'value', 'query-segment-value'),\n    ];\n\n    this.serverFilterSegments.pop();\n    this.serverFilterSegments.push(segmentArray);\n    this.serverFilterSegments.push([this.uiSegmentSrv.newPlusButton()]);\n  };\n\n  /**\n   * Called when a response filter configuration is changed.\n   *\n   * @param segment the segment which has been changed\n   */\n  onServerFilterSegmentUpdate = segment => {\n    if (segment.type === 'plus-button') {\n      this._addServerFilterSegment(segment);\n      return;\n    }\n\n    this._updateFilterTarget();\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Returns selectable options for filter segments.\n   */\n  getFilterSegmentOptions = (segment, parentIndex, index) => {\n    let segments: any[] = [];\n\n    if (segment.type === 'operator') {\n      segments = this.uiSegmentSrv.newOperators(['==', '=~', '!=', '!~', '<', '>']);\n    } else if (this.dataPreview && this.dataPreview.length > 0) {\n      let options: string[] = [];\n      if (index === 0) {\n        options = this.getAllDeepKeys();\n      } else if (index === 2) {\n        const filterKey = this.clientFilterSegments[parentIndex][0].value;\n        options = _(this.dataPreview)\n          .map(data => _.get(data, filterKey))\n          .uniq()\n          .value();\n\n        _.each(this.templateSrv.variables, variable =>\n          options.unshift('/$' + variable.name + '/')\n        );\n      }\n      segments = _.map(options, option => this.uiSegmentSrv.newSegment(String(option)));\n    }\n\n    return this.$q.when(segments);\n  };\n\n  /**\n   * The segments which represents the specified filters will not be persisted and passed to the data source.\n   * Instead, an object is created which represents the filters which is passed to the data source and\n   * persisted by Grafana. Calling this method syncs the object (target) and updates its value to match the\n   * segments' values specified by the user.\n   */\n  _updateFilterTarget = () => {\n    const target = <GrafanaTarget>this.target;\n\n    // update client filters\n    const clientFilters = _(this.clientFilterSegments)\n      .filter(segmentArray => segmentArray.length === 3)\n      .filter(segmentArray => !segmentArray[2].fake)\n      .map(segmentArray => {\n        return <ClientSideFilter>{\n          key: segmentArray[0].value,\n          matcher: segmentArray[1].value,\n          value: segmentArray[2].value,\n        };\n      })\n      .value();\n\n    target.clientSideFilters = clientFilters;\n\n    // update server filters\n    const serverFilters = _(this.serverFilterSegments)\n      .filter(segmentArray => segmentArray.length === 4)\n      .filter(segmentArray => !segmentArray[1].fake && !segmentArray[3].fake)\n      .map(segmentArray => {\n        let type;\n        switch (segmentArray[0].value) {\n          case 'fieldSelector':\n            type = ServerSideFilterType.FIELD;\n            break;\n          case 'labelSelector':\n            type = ServerSideFilterType.LABEL;\n            break;\n          default:\n            return <ServerSideFilter>{};\n        }\n\n        return <ServerSideFilter>{\n          key: segmentArray[1].value,\n          matcher: segmentArray[2].value,\n          value: segmentArray[3].value,\n          type,\n        };\n      })\n      .filter(filter => filter.type !== undefined)\n      .value();\n\n    target.serverSideFilters = serverFilters;\n  };\n\n  /**\n   * Returns all existing keys of the current data preview.\n   */\n  getAllDeepKeys = () => {\n    return _.flatMap(this.combineKeys(this.dataPreview[0]), e => e);\n  };\n\n  /**\n   * Returns selectable options for the field segments.\n   */\n  getFieldSelectorOptions = (segment, parentIndex, index) => {\n    let segments: any[] = [];\n\n    if (this.dataPreview && this.dataPreview.length > 0) {\n      let options: string[] = [];\n\n      let currentSelection: any = this.dataPreview[0];\n\n      if (index > 0) {\n        for (let i = 0; i < index; i++) {\n          const fieldSegment = this.target.fieldSelectors[parentIndex].fieldSegments[i];\n          currentSelection = _.get(currentSelection, fieldSegment.value);\n        }\n      }\n\n      options = _.concat(options, ['*']);\n      options = _.concat(options, Object.keys(currentSelection));\n\n      options.sort();\n\n      segments = _.map(options, option => this.uiSegmentSrv.newSegment({value: option}));\n    }\n\n    return this.$q.when(segments);\n  };\n\n  /**\n   * Called if a field segment is changed.\n   */\n  onFieldSelectorSegmentUpdate = (segment, parentIndex) => {\n    if (segment == this.addFieldSegment) {\n      this.target.fieldSelectors.push(new FieldSelector(this, segment.value));\n      this.addFieldSegment = this.uiSegmentSrv.newPlusButton();\n    } else {\n      this.target.fieldSelectors[parentIndex].refresh(this);\n    }\n\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Removes the field selector on the specified index.\n   */\n  removeField = index => {\n    this.target.fieldSelectors.splice(index, 1);\n    this.panelCtrl.refresh();\n  };\n\n  /**\n   * Called if an alias is changing.\n   */\n  onAliasChange = () => {\n    this.panelCtrl.refresh();\n  };\n\n  combineKeys = object => {\n    const keys: string[] = Object.keys(object);\n\n    return _.flatMap(keys, key => {\n      if (_.isPlainObject(object[key])) {\n        return _.map(this.combineKeys(object[key]), nestedKeys => {\n          return key + '.' + nestedKeys;\n        });\n      } else {\n        return key;\n      }\n    });\n  };\n\n  /**\n   * Returns the currently selected api endpoint.\n   */\n  _getCurrentApi = () => {\n    return _.find(API_ENDPOINTS, {value: this.target.apiEndpoints});\n  };\n\n  getServerFilterOptions = (segment, parentIndex) => {\n    if (segment.type === 'operator') {\n      return this.$q.when(\n        this.uiSegmentSrv.newOperators(['==', '!=', 'in', 'notin', 'matches'])\n      );\n    } else if (segment.type === 'plus-button' || segment.type === 'condition') {\n      return this.$q.when(\n        _.map(['fieldSelector', 'labelSelector'], value =>\n          this.uiSegmentSrv.newSegment({value})\n        )\n      );\n    }\n\n    const options: string[] = _.map(\n      this.templateSrv.variables,\n      variable => '\"$' + variable.name + '\"'\n    );\n\n    const filterType = this.serverFilterSegments[parentIndex][0].value;\n\n    if (filterType === 'fieldSelector') {\n      const currentApi = this._getCurrentApi();\n      if (currentApi) {\n        currentApi.fieldSelectors.forEach(field => options.push(field));\n      }\n    }\n\n    const segments = _.map(options, option =>\n      this.uiSegmentSrv.newSegment(new String(option))\n    );\n\n    return this.$q.when(segments);\n  };\n\n  onDataReceived = () => {\n    if (this.dataPreviewBuffer.length > 0) {\n      // this is done so that we get the response from all querys. otherwise the last query could override the\n      // data which we need\n      //\n      // TODO only store the data related to the current query\n      this.dataPreview = _.flatten(this.dataPreviewBuffer);\n      this.dataPreviewBuffer = [];\n    }\n  };\n\n  /**\n   * Called when a request is finished. The requests data is stored and used as a data preview which is basis for auto completions.\n   */\n  onResponseReceived = response => {\n    if (!response.config.url.endsWith('/auth')) {\n      this.dataPreviewBuffer.push(response.data);\n    }\n  };\n\n  onRefresh = () => {\n    //TODO\n    this.dataPreview = {};\n  };\n\n  /**\n   * Returns a string representation of the current query configuration.\n   */\n  getCollapsedText() {\n    return targetToQueryString(this.target);\n  }\n}\n","import {InstanceSettings} from './types';\r\n\r\n/**\r\n * Controller responsible for the configuration ui.\r\n */\r\nexport class SensuConfigCtrl {\r\n  static templateUrl = 'partials/config.html';\r\n\r\n  // the current datasource settings\r\n  current: InstanceSettings;\r\n\r\n  /** @ngInject **/\r\n  constructor($scope) {\r\n    $scope.$watch(\r\n      () => this.current.url,\r\n      value => (this.current.jsonData.currentUrl = value)\r\n    );\r\n    $scope.$watch(\r\n      () => this.current.basicAuth,\r\n      value => {\r\n        if (value) {\r\n          this.current.jsonData.useApiKey = false;\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * When the \"Use API Key\" option is toggled.\r\n   */\r\n  onUseApiKeyToggle = () => {\r\n    const current = this.current;\r\n    if (current.jsonData.useApiKey) {\r\n      current.basicAuth = false;\r\n      this.resetApiKey();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Resets the currely set API key.\r\n   */\r\n  resetApiKey = () => {\r\n    this.current.secureJsonFields.apiKey = false;\r\n    this.current.secureJsonData = this.current.secureJsonData || {};\r\n    this.current.secureJsonData.apiKey = '';\r\n  };\r\n}\r\n"],"sourceRoot":""}